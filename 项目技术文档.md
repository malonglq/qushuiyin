# 去水印小程序项目技术文档（纯前端方案）

## 项目概述

### 项目背景
随着社交媒体和内容创作的快速发展，用户经常需要处理带有水印的图片。现有的去水印工具存在操作复杂、处理效果不佳、隐私安全等问题。本项目旨在开发一个**纯前端**的智能、高效、安全的去水印小程序，所有处理都在用户设备上完成，完全保护用户隐私。

### 项目目标
- **技术目标**：构建一个基于纯前端的去水印工具，支持传统上传和链接读取两种模式
- **性能目标**：单张图片处理时间 < 5秒，批量处理支持多张图片
- **用户体验目标**：操作步骤 ≤ 3步，支持一键智能识别和处理
- **隐私目标**：所有处理在本地完成，数据不上传任何服务器
- **成本目标**：零服务器成本，无需后端维护

### 技术栈总览
- **前端**：微信原生小程序 (WXML/WXSS/JavaScript)
- **图像处理**：Canvas API + WebAssembly + OpenCV.js
- **数据存储**：IndexedDB + LocalStorage
- **性能优化**：WebWorker + 分块处理 + 渐进式加载
- **链接解析**：前端JavaScript + CORS代理
- **部署**：微信小程序直接发布

---

## 技术选型分析

### 前端技术选型

#### 微信原生小程序
**选择理由：**
- 用户基数庞大，无需额外下载安装
- 原生性能最佳，用户体验流畅
- 完善的本地存储和文件系统API
- 丰富的API支持（相机、相册、剪贴板等）

**技术优势：**
- 接近原生应用的性能
- 完整的微信生态集成
- 丰富的UI组件和API
- 完善的开发工具链

#### 图像处理技术选型

##### Canvas API + 自定义算法
**选择理由：**
- 微信小程序原生支持
- 无需额外依赖
- 处理速度快
- 可控性强

**核心算法：**
```javascript
// 基于邻域像素的图像修复算法
async function inpaint(imageData, maskData) {
  const { width, height, data } = imageData;
  const result = new Uint8ClampedArray(data.length);
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const idx = (y * width + x) * 4;
      
      if (maskData[idx] > 0) {
        // 获取周围像素平均值进行修复
        const neighbors = getNeighbors(data, x, y, width, height);
        const avgR = neighbors.reduce((sum, n) => sum + n.r, 0) / neighbors.length;
        const avgG = neighbors.reduce((sum, n) => sum + n.g, 0) / neighbors.length;
        const avgB = neighbors.reduce((sum, n) => sum + n.b, 0) / neighbors.length;
        
        result[idx] = avgR;
        result[idx + 1] = avgG;
        result[idx + 2] = avgB;
        result[idx + 3] = 255;
      } else {
        result[idx] = data[idx];
        result[idx + 1] = data[idx + 1];
        result[idx + 2] = data[idx + 2];
        result[idx + 3] = data[idx + 3];
      }
    }
  }
  
  return new ImageData(result, width, height);
}
```

##### WebAssembly + OpenCV.js
**选择理由：**
- 高性能图像处理
- 成熟的计算机视觉算法
- 接近原生性能
- 丰富的图像处理功能

**实现方案：**
```javascript
// 加载OpenCV.js
async function loadOpenCV() {
  return new Promise((resolve) => {
    const script = document.createElement('script');
    script.src = 'https://docs.opencv.org/master/opencv.js';
    script.onload = resolve;
    document.head.appendChild(script);
  });
}

// 使用OpenCV进行图像修复
async function cvInpaint(imageData, maskData) {
  await loadOpenCV();
  
  let src = cv.matFromImageData(imageData);
  let mask = cv.matFromImageData(maskData);
  let dst = new cv.Mat();
  
  cv.inpaint(src, mask, dst, 3, cv.INPAINT_TELEA);
  
  return dst;
}
```

#### 数据存储技术选型

##### IndexedDB
**选择理由：**
- 大容量本地存储
- 支持复杂数据结构
- 异步操作，不阻塞主线程
- 完善的事务支持

**实现方案：**
```javascript
class StorageManager {
  constructor() {
    this.dbName = 'WatermarkRemoverDB';
    this.version = 1;
    this.db = null;
    this.initDB();
  }

  async initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // 创建历史记录存储
        if (!db.objectStoreNames.contains('history')) {
          const historyStore = db.createObjectStore('history', {
            keyPath: 'id',
            autoIncrement: true
          });
          historyStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
        
        // 创建设置存储
        if (!db.objectStoreNames.contains('settings')) {
          db.createObjectStore('settings', { keyPath: 'key' });
        }
        
        // 创建缓存存储
        if (!db.objectStoreNames.contains('cache')) {
          const cacheStore = db.createObjectStore('cache', { keyPath: 'url' });
          cacheStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }

  async saveHistory(record) {
    const transaction = this.db.transaction(['history'], 'readwrite');
    const store = transaction.objectStore('history');
    
    const historyRecord = {
      ...record,
      id: Date.now().toString(),
      timestamp: new Date().toISOString()
    };
    
    return new Promise((resolve, reject) => {
      const request = store.add(historyRecord);
      request.onsuccess = () => resolve(historyRecord);
      request.onerror = () => reject(request.error);
    });
  }
}
```

##### LocalStorage
**选择理由：**
- 简单易用
- 同步操作
- 适合存储少量数据
- 兼容性好

**使用场景：**
- 用户设置
- 应用状态
- 缓存数据

### 链接解析技术选型

#### 前端JavaScript解析
**选择理由：**
- 完全前端实现
- 无需后端支持
- 实时处理
- 隐私保护

**实现方案：**
```javascript
class LinkParser {
  constructor() {
    this.platforms = {
      xiaohongshu: {
        name: '小红书',
        patterns: [
          /xiaohongshu\.com\/explore\/.+/,
          /xhslink\.com\/.+/,
          /xiaohongshu\.com\/discovery\/item\/.+/
        ],
        parser: this.parseXiaohongshu.bind(this)
      },
      douyin: {
        name: '抖音',
        patterns: [
          /douyin\.com\/video\/.+/,
          /iesdouyin\.com\/share\/video\/.+/,
          /v\.douyin\.com\/.+/
        ],
        parser: this.parseDouyin.bind(this)
      },
      weibo: {
        name: '微博',
        patterns: [
          /weibo\.com\/.+/,
          /m\.weibo\.cn\/.+/
        ],
        parser: this.parseWeibo.bind(this)
      },
      wechat: {
        name: '微信',
        patterns: [
          /mp\.weixin\.qq\.com\/.+/,
          /weixin\.qq\.com\/.+/
        ],
        parser: this.parseWechat.bind(this)
      }
    };
  }

  async parseLink(url) {
    try {
      const platform = this.detectPlatform(url);
      
      if (!platform) {
        throw new Error('不支持的平台或链接格式');
      }

      // 使用CORS代理获取内容
      const content = await this.fetchWithProxy(url);
      
      // 解析图片链接
      const images = await platform.parser(content, url);
      
      return {
        platform: platform.name,
        url: url,
        images: images,
        timestamp: Date.now()
      };
    } catch (error) {
      console.error('链接解析失败:', error);
      throw error;
    }
  }

  async fetchWithProxy(url) {
    // 使用公共CORS代理
    const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
    
    try {
      const response = await fetch(proxyUrl, {
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return await response.text();
    } catch (error) {
      // 尝试备用代理
      return await this.fetchWithAlternativeProxy(url);
    }
  }

  async parseXiaohongshu(content, url) {
    const images = [];
    const parser = new DOMParser();
    const doc = parser.parseFromString(content, 'text/html');
    
    // 提取图片链接
    const imgElements = doc.querySelectorAll('img');
    imgElements.forEach(img => {
      const src = img.src || img.dataset.src;
      if (src && this.isImageUrl(src)) {
        images.push({
          url: this.resolveUrl(src, url),
          thumbnail: this.getThumbnailUrl(src),
          width: img.naturalWidth,
          height: img.naturalHeight
        });
      }
    });

    return images;
  }

  isImageUrl(url) {
    return /\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(url);
  }

  resolveUrl(url, baseUrl) {
    try {
      return new URL(url, baseUrl).href;
    } catch (e) {
      return url;
    }
  }
}
```

---

## 架构设计

### 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    纯前端架构                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐    ┌─────────────────┐               │
│  │   微信小程序     │    │   浏览器版本     │               │
│  │                 │    │                 │               │
│  │  ┌───────────┐  │    │  ┌───────────┐  │               │
│  │  │   UI层    │  │    │  │   UI层    │  │               │
│  │  │  WXML/WXSS │  │    │  │  HTML/CSS │  │               │
│  │  └───────────┘  │    │  └───────────┘  │               │
│  │                 │    │                 │               │
│  │  ┌───────────┐  │    │  ┌───────────┐  │               │
│  │  │   逻辑层   │  │    │  │   逻辑层   │  │               │
│  │  │ JavaScript │  │    │  │ JavaScript │  │               │
│  │  └───────────┘  │    │  └───────────┘  │               │
│  │                 │    │                 │               │
│  │  ┌───────────┐  │    │  ┌───────────┐  │               │
│  │  │   处理层   │  │    │  │   处理层   │  │               │
│  │  │ WebWorker  │  │    │  │ WebWorker  │  │               │
│  │  └───────────┘  │    │  └───────────┘  │               │
│  └─────────────────┘    └─────────────────┘               │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                    核心算法层                                │
│                                                             │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
│  │   图像处理      │  │   链接解析      │  │   数据存储   │ │
│  │                 │  │                 │  │             │ │
│  │  Canvas API    │  │  跨域代理      │  │  IndexedDB   │ │
│  │  WebAssembly   │  │  DOM解析       │  │ LocalStorage│ │
│  │  OpenCV.js     │  │  正则表达式     │  │  缓存管理    │ │
│  │  纯JS算法      │  │  平台识别      │  │  数据同步    │ │
│  └─────────────────┘  └─────────────────┘  └─────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 模块设计

#### 1. 核心处理模块

```javascript
// /utils/image-processor.js
class ImageProcessor {
  constructor() {
    this.canvas = null;
    this.ctx = null;
  }

  // 初始化Canvas
  initCanvas(width, height) {
    this.canvas = document.createElement('canvas');
    this.canvas.width = width;
    this.canvas.height = height;
    this.ctx = this.canvas.getContext('2d');
  }

  // 水印检测
  async detectWatermark(imageData) {
    const { width, height, data } = imageData;
    const mask = new Uint8ClampedArray(width * height * 4);
    
    // 简单的水印检测算法
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        
        // 检测亮色水印
        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        const isWatermark = brightness > 200; // 阈值可调
        
        if (isWatermark) {
          mask[idx] = 255;
          mask[idx + 1] = 255;
          mask[idx + 2] = 255;
          mask[idx + 3] = 255;
        }
      }
    }
    
    return new ImageData(mask, width, height);
  }

  // 图像修复
  async inpaint(imageData, maskData) {
    const { width, height, data } = imageData;
    const result = new Uint8ClampedArray(data.length);
    
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = (y * width + x) * 4;
        
        if (maskData[idx] > 0) {
          // 获取周围像素平均值进行修复
          const neighbors = this.getNeighbors(data, x, y, width, height);
          const avgR = neighbors.reduce((sum, n) => sum + n.r, 0) / neighbors.length;
          const avgG = neighbors.reduce((sum, n) => sum + n.g, 0) / neighbors.length;
          const avgB = neighbors.reduce((sum, n) => sum + n.b, 0) / neighbors.length;
          
          result[idx] = avgR;
          result[idx + 1] = avgG;
          result[idx + 2] = avgB;
          result[idx + 3] = 255;
        } else {
          result[idx] = data[idx];
          result[idx + 1] = data[idx + 1];
          result[idx + 2] = data[idx + 2];
          result[idx + 3] = data[idx + 3];
        }
      }
    }
    
    return new ImageData(result, width, height);
  }

  // 获取周围像素
  getNeighbors(data, x, y, width, height) {
    const neighbors = [];
    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];

    for (const [dx, dy] of directions) {
      const nx = x + dx;
      const ny = y + dy;
      
      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
        const idx = (ny * width + nx) * 4;
        neighbors.push({
          r: data[idx],
          g: data[idx + 1],
          b: data[idx + 2]
        });
      }
    }
    
    return neighbors;
  }
}
```

#### 2. 性能优化模块

```javascript
// /utils/performance-optimizer.js
class PerformanceOptimizer {
  constructor() {
    this.workerPool = [];
    this.maxWorkers = navigator.hardwareConcurrency || 4;
    this.initWorkerPool();
  }

  // 初始化Worker池
  initWorkerPool() {
    for (let i = 0; i < this.maxWorkers; i++) {
      const worker = new Worker('/workers/image-processor.worker.js');
      this.workerPool.push({
        worker: worker,
        busy: false
      });
    }
  }

  // 分块处理大图片
  async processLargeImage(imageData, blockSize = 512) {
    const { width, height, data } = imageData;
    const result = new Uint8ClampedArray(data.length);
    
    // 分块处理
    for (let y = 0; y < height; y += blockSize) {
      for (let x = 0; x < width; x += blockSize) {
        const blockWidth = Math.min(blockSize, width - x);
        const blockHeight = Math.min(blockSize, height - y);
        
        // 提取块数据
        const blockData = this.extractBlock(data, x, y, blockWidth, blockHeight, width);
        
        // 处理块
        const processedBlock = await this.processBlock(blockData, blockWidth, blockHeight);
        
        // 合并结果
        this.mergeBlock(result, processedBlock, x, y, blockWidth, blockHeight, width);
      }
    }
    
    return new ImageData(result, width, height);
  }

  // 图片压缩
  async compressImage(imageData, quality = 0.8) {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // 计算压缩后的尺寸
      const maxSize = 1920;
      let { width, height } = imageData;
      
      if (width > maxSize || height > maxSize) {
        const ratio = Math.min(maxSize / width, maxSize / height);
        width *= ratio;
        height *= ratio;
      }
      
      canvas.width = width;
      canvas.height = height;
      
      // 绘制压缩后的图片
      ctx.drawImage(imageData, 0, 0, width, height);
      
      // 转换为Blob
      canvas.toBlob((blob) => {
        resolve({
          blob: blob,
          width: width,
          height: height
        });
      }, 'image/jpeg', quality);
    });
  }
}
```

### 数据流设计

```
用户输入 → 图片/链接 → 预处理 → 水印检测 → 图像修复 → 结果输出 → 本地存储
    ↓         ↓         ↓          ↓          ↓          ↓          ↓
  UI层    →  处理层   →  缓存层   →  算法层   →  优化层   →  输出层   →  存储层
```

### 状态管理

```javascript
// /utils/state-manager.js
class StateManager {
  constructor() {
    this.state = {
      processing: false,
      progress: 0,
      currentStep: 1,
      images: [],
      settings: {
        quality: 'high',
        autoSave: true,
        batchProcessing: true
      }
    };
    this.listeners = [];
  }

  // 更新状态
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notifyListeners();
  }

  // 获取状态
  getState() {
    return this.state;
  }

  // 添加监听器
  addListener(callback) {
    this.listeners.push(callback);
  }

  // 通知监听器
  notifyListeners() {
    this.listeners.forEach(callback => callback(this.state));
  }
}
```

---

## API接口设计

### 内部API设计

#### 1. 图像处理API

```javascript
// /api/image-processor.js
class ImageProcessorAPI {
  constructor() {
    this.processor = new ImageProcessor();
    this.optimizer = new PerformanceOptimizer();
  }

  // 处理单张图片
  async processImage(imagePath, options = {}) {
    try {
      // 获取图片信息
      const imageInfo = await this.getImageInfo(imagePath);
      
      // 压缩图片
      const compressedImage = await this.optimizer.compressImage(imageInfo);
      
      // 创建Canvas
      const canvas = await this.createCanvas(compressedImage.width, compressedImage.height);
      const ctx = canvas.getContext('2d');
      
      // 绘制图片
      await this.drawImage(ctx, compressedImage, compressedImage.width, compressedImage.height);
      
      // 获取图片数据
      const imageData = ctx.getImageData(0, 0, compressedImage.width, compressedImage.height);
      
      // 检测水印
      const maskData = await this.processor.detectWatermark(imageData);
      
      // 去除水印
      const resultData = await this.processor.inpaint(imageData, maskData);
      
      // 保存结果
      const resultPath = await this.saveResultImage(canvas, resultData);
      
      return {
        success: true,
        resultPath: resultPath,
        originalPath: imagePath,
        processingTime: Date.now()
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // 批量处理图片
  async batchProcessImages(imagePaths, options = {}) {
    const results = [];
    
    for (let i = 0; i < imagePaths.length; i++) {
      const imagePath = imagePaths[i];
      
      try {
        const result = await this.processImage(imagePath, options);
        results.push(result);
        
        // 更新进度
        this.updateProgress({
          current: i + 1,
          total: imagePaths.length,
          progress: ((i + 1) / imagePaths.length) * 100
        });
        
      } catch (error) {
        results.push({
          success: false,
          error: error.message,
          imagePath: imagePath
        });
      }
    }
    
    return results;
  }
}
```

#### 2. 链接解析API

```javascript
// /api/link-parser.js
class LinkParserAPI {
  constructor() {
    this.parser = new LinkParser();
  }

  // 解析链接
  async parseLink(url) {
    try {
      const result = await this.parser.parseLink(url);
      
      return {
        success: true,
        data: result
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // 批量解析链接
  async batchParseLinks(urls) {
    const results = [];
    
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      
      try {
        const result = await this.parseLink(url);
        results.push(result);
        
      } catch (error) {
        results.push({
          success: false,
          error: error.message,
          url: url
        });
      }
    }
    
    return results;
  }

  // 获取支持的平台
  getSupportedPlatforms() {
    return [
      { name: '小红书', icon: '📕', color: '#fe2c55' },
      { name: '抖音', icon: '📱', color: '#000000' },
      { name: '微博', icon: '🌐', color: '#e6162d' },
      { name: '微信', icon: '📖', color: '#07c160' }
    ];
  }
}
```

#### 3. 存储管理API

```javascript
// /api/storage-manager.js
class StorageManagerAPI {
  constructor() {
    this.storage = new StorageManager();
  }

  // 保存历史记录
  async saveHistory(record) {
    try {
      const result = await this.storage.saveHistory(record);
      
      return {
        success: true,
        data: result
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // 获取历史记录
  async getHistory(params = {}) {
    try {
      const { page = 1, pageSize = 20, type = null } = params;
      const result = await this.storage.getHistory(page, pageSize, type);
      
      return {
        success: true,
        data: result
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // 删除历史记录
  async deleteHistory(id) {
    try {
      await this.storage.deleteHistory(id);
      
      return {
        success: true
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // 保存设置
  async saveSettings(key, value) {
    try {
      await this.storage.saveSettings(key, value);
      
      return {
        success: true
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // 获取设置
  async getSettings(key) {
    try {
      const result = await this.storage.getSettings(key);
      
      return {
        success: true,
        data: result
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
}
```

---

## 数据库设计

### IndexedDB 数据结构

#### 1. 历史记录表 (history)

```javascript
{
  "id": "1630000000000",              // 主键，时间戳
  "type": "traditional",              // 类型：traditional | link
  "timestamp": "2023-08-24T10:00:00Z", // 处理时间
  "originalPath": "/tmp/original.jpg", // 原图路径
  "resultPath": "/tmp/result.jpg",     // 结果路径
  "imageSize": 1920000,               // 图片大小
  "processingTime": 2500,             // 处理时间(ms)
  "quality": 4.5,                     // 质量评分
  "platform": "小红书",               // 平台（链接模式）
  "originalUrl": "https://...",        // 原始链接（链接模式）
  "images": [                         // 图片列表（链接模式）
    {
      "url": "https://...",
      "resultPath": "/tmp/result1.jpg",
      "processed": true,
      "fileSize": 1024000
    }
  ]
}
```

#### 2. 设置表 (settings)

```javascript
{
  "key": "imageQuality",               // 设置键
  "value": "high",                    // 设置值
  "updatedAt": "2023-08-24T10:00:00Z" // 更新时间
}
```

#### 3. 缓存表 (cache)

```javascript
{
  "url": "https://example.com/image.jpg", // 缓存键
  "data": "base64_encoded_image_data",   // 缓存数据
  "timestamp": "2023-08-24T10:00:00Z",   // 缓存时间
  "expiresAt": "2023-08-31T10:00:00Z"     // 过期时间
}
```

### 数据操作接口

```javascript
// /database/operations.js
class DatabaseOperations {
  constructor() {
    this.db = null;
    this.initDB();
  }

  async initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('WatermarkRemoverDB', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // 创建历史记录表
        if (!db.objectStoreNames.contains('history')) {
          const historyStore = db.createObjectStore('history', {
            keyPath: 'id',
            autoIncrement: true
          });
          historyStore.createIndex('timestamp', 'timestamp', { unique: false });
          historyStore.createIndex('type', 'type', { unique: false });
        }
        
        // 创建设置表
        if (!db.objectStoreNames.contains('settings')) {
          db.createObjectStore('settings', { keyPath: 'key' });
        }
        
        // 创建缓存表
        if (!db.objectStoreNames.contains('cache')) {
          const cacheStore = db.createObjectStore('cache', { keyPath: 'url' });
          cacheStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }

  // 查询历史记录
  async queryHistory(params = {}) {
    const { page = 1, pageSize = 20, type = null, startDate, endDate } = params;
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['history'], 'readonly');
      const store = transaction.objectStore('history');
      
      let request;
      if (type) {
        const index = store.index('type');
        request = index.openCursor(IDBKeyRange.only(type));
      } else {
        request = store.openCursor();
      }
      
      const records = [];
      let count = 0;
      const start = (page - 1) * pageSize;
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        
        if (cursor) {
          const record = cursor.value;
          
          // 日期过滤
          if (startDate && new Date(record.timestamp) < new Date(startDate)) {
            cursor.continue();
            return;
          }
          
          if (endDate && new Date(record.timestamp) > new Date(endDate)) {
            cursor.continue();
            return;
          }
          
          if (count >= start && count < start + pageSize) {
            records.push(record);
          }
          count++;
          cursor.continue();
        } else {
          resolve({
            records: records,
            total: count,
            page: page,
            pageSize: pageSize
          });
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  // 统计查询
  async getStatistics() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['history'], 'readonly');
      const store = transaction.objectStore('history');
      
      const request = store.getAll();
      
      request.onsuccess = () => {
        const records = request.result;
        
        const statistics = {
          total: records.length,
          traditional: records.filter(r => r.type === 'traditional').length,
          link: records.filter(r => r.type === 'link').length,
          success: records.filter(r => r.quality > 3).length,
          platforms: {},
          monthlyData: {}
        };
        
        // 平台统计
        records.forEach(record => {
          if (record.platform) {
            statistics.platforms[record.platform] = (statistics.platforms[record.platform] || 0) + 1;
          }
        });
        
        // 月度统计
        records.forEach(record => {
          const month = new Date(record.timestamp).toISOString().substring(0, 7);
          statistics.monthlyData[month] = (statistics.monthlyData[month] || 0) + 1;
        });
        
        resolve(statistics);
      };
      
      request.onerror = () => reject(request.error);
    });
  }
}
```

---

## 部署方案

### 微信小程序部署

#### 1. 开发环境配置

```json
// project.config.json
{
  "description": "项目配置文件",
  "packOptions": {
    "ignore": [],
    "include": []
  },
  "miniprogramRoot": "miniprogram/",
  "compileType": "miniprogram",
  "projectname": "去水印小程序",
  "setting": {
    "useCompilerPlugins": [
      "sass"
    ],
    "babelSetting": {
      "ignore": [],
      "disablePlugins": [],
      "outputPath": ""
    },
    "es6": true,
    "enhance": true,
    "postcss": true,
    "condition": false,
    "packNpmManually": false,
    "packNpmRelationList": [],
    "minifyWXSS": true,
    "minifyWXML": true,
    "showES6CompileOption": false,
    "useMultiFrameRuntime": true,
    "useApiHook": true,
    "useApiHostProcess": true
  },
  "simulatorType": "wechat",
  "simulatorPluginLibVersion": {},
  "condition": {},
  "srcMiniprogramRoot": "miniprogram/",
  "appid": "your_appid_here",
  "libVersion": "2.32.3",
  "editorSetting": {
    "tabIndent": "insertSpaces",
    "tabSize": 2
  }
}
```

#### 2. 小程序配置

```json
// app.json
{
  "pages": [
    "pages/index/index",
    "pages/link-process/index",
    "pages/result/index",
    "pages/history/index",
    "pages/settings/index"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#4A90E2",
    "navigationBarTitleText": "智能去水印助手",
    "navigationBarTextStyle": "white"
  },
  "tabBar": {
    "color": "#7A7E83",
    "selectedColor": "#4A90E2",
    "backgroundColor": "#ffffff",
    "borderStyle": "black",
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "images/home.png",
        "selectedIconPath": "images/home-active.png"
      },
      {
        "pagePath": "pages/history/index",
        "text": "历史",
        "iconPath": "images/history.png",
        "selectedIconPath": "images/history-active.png"
      },
      {
        "pagePath": "pages/settings/index",
        "text": "设置",
        "iconPath": "images/settings.png",
        "selectedIconPath": "images/settings-active.png"
      }
    ]
  },
  "permission": {
    "scope.writePhotosAlbum": {
      "desc": "需要保存处理后的图片到相册"
    },
    "scope.camera": {
      "desc": "需要使用相机拍照"
    }
  },
  "requiredBackgroundModes": ["download"],
  "lazyCodeLoading": "requiredComponents"
}
```

#### 3. 权限配置

```json
// app.json
"permission": {
  "scope.writePhotosAlbum": {
    "desc": "需要保存处理后的图片到相册"
  },
  "scope.camera": {
    "desc": "需要使用相机拍照"
  }
}
```

#### 4. 发布流程

```bash
# 1. 本地开发调试
npm run dev

# 2. 代码检查
npm run lint

# 3. 构建生产版本
npm run build

# 4. 上传代码到微信开发者工具
# 5. 提交审核
# 6. 发布上线
```

### Web版本部署（可选）

#### 1. Vite配置

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  base: './',
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    rollupOptions: {
      output: {
        manualChunks: {
          'opencv': ['opencv.js'],
          'worker': ['./workers/image-processor.worker.js']
        }
      }
    }
  },
  server: {
    port: 3000,
    open: true
  }
})
```

#### 2. 静态部署

```bash
# 构建Web版本
npm run build:web

# 部署到GitHub Pages
npm run deploy:github

# 部署到Netlify
npm run deploy:netlify
```

---

## 开发规范

### 代码规范

#### 1. JavaScript规范

```javascript
// 使用ES6+语法
import ImageProcessor from './image-processor.js';

// 使用async/await处理异步
class ImageService {
  async processImage(imagePath) {
    try {
      const processor = new ImageProcessor();
      const result = await processor.process(imagePath);
      return result;
    } catch (error) {
      console.error('处理失败:', error);
      throw error;
    }
  }
}

// 使用类和模块化
export default ImageService;
```

#### 2. CSS规范

```css
/* 使用BEM命名规范 */
.watermark-remover {
  &__header {
    /* 头部样式 */
  }
  
  &__content {
    /* 内容样式 */
  }
  
  &--active {
    /* 激活状态 */
  }
}

/* 使用CSS变量 */
:root {
  --primary-color: #4A90E2;
  --secondary-color: #7B68EE;
  --success-color: #52C41A;
  --warning-color: #FAAD14;
  --error-color: #F5222D;
}
```

#### 3. 文件命名规范

```
# 页面文件
pages/index/index.js
pages/index/index.wxml
pages/index/index.wxss
pages/index/index.json

# 组件文件
components/image-uploader/image-uploader.js
components/image-uploader/image-uploader.wxml
components/image-uploader/image-uploader.wxss
components/image-uploader/image-uploader.json

# 工具文件
utils/image-processor.js
utils/link-parser.js
utils/storage-manager.js

# 样式文件
styles/common.wxss
styles/variables.wxss
```

### Git工作流

#### 1. 分支策略

```bash
# 主分支
main (生产环境)
develop (开发环境)

# 功能分支
feature/image-processing
feature/link-parser
feature/storage-system

# 修复分支
bugfix/memory-leak
bugfix/cors-issue
```

#### 2. 提交规范

```bash
# 提交格式
<type>(<scope>): <description>

# 类型说明
feat: 新功能
fix: 修复bug
docs: 文档更新
style: 代码格式
refactor: 重构
test: 测试
chore: 构建或工具变动

# 示例
feat(image): 添加图像处理功能
fix(parser): 修复链接解析跨域问题
docs(readme): 更新项目文档
style(format): 代码格式化
```

#### 3. 代码检查

```javascript
// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true
  },
  extends: [
    'eslint:recommended',
    '@vue/eslint-config-prettier'
  ],
  parserOptions: {
    ecmaVersion: 12,
    sourceType: 'module'
  },
  rules: {
    'no-console': 'warn',
    'no-unused-vars': 'error',
    'prefer-const': 'error',
    'no-var': 'error'
  }
}
```

### 测试规范

#### 1. 单元测试

```javascript
// tests/unit/image-processor.test.js
import ImageProcessor from '../../utils/image-processor.js';

describe('ImageProcessor', () => {
  let processor;

  beforeEach(() => {
    processor = new ImageProcessor();
  });

  test('should detect watermark', async () => {
    const imageData = createMockImageData();
    const maskData = await processor.detectWatermark(imageData);
    
    expect(maskData).toBeDefined();
    expect(maskData.width).toBe(imageData.width);
    expect(maskData.height).toBe(imageData.height);
  });

  test('should inpaint image', async () => {
    const imageData = createMockImageData();
    const maskData = createMockMaskData();
    const resultData = await processor.inpaint(imageData, maskData);
    
    expect(resultData).toBeDefined();
    expect(resultData.width).toBe(imageData.width);
    expect(resultData.height).toBe(imageData.height);
  });
});
```

#### 2. 集成测试

```javascript
// tests/integration/link-parser.test.js
import LinkParser from '../../utils/link-parser.js';

describe('LinkParser', () => {
  let parser;

  beforeEach(() => {
    parser = new LinkParser();
  });

  test('should parse xiaohongshu link', async () => {
    const url = 'https://www.xiaohongshu.com/explore/123456';
    const result = await parser.parseLink(url);
    
    expect(result.platform).toBe('小红书');
    expect(result.images).toBeDefined();
    expect(result.images.length).toBeGreaterThan(0);
  });

  test('should handle invalid link', async () => {
    const url = 'https://invalid-url.com';
    
    await expect(parser.parseLink(url)).rejects.toThrow();
  });
});
```

---

## 测试方案

### 单元测试

#### 1. 图像处理测试

```javascript
// tests/unit/image-processing.test.js
import { expect, test } from '@jest/globals';
import ImageProcessor from '../../utils/image-processor.js';

describe('Image Processing', () => {
  let processor;

  beforeEach(() => {
    processor = new ImageProcessor();
  });

  test('should create canvas with correct dimensions', () => {
    processor.initCanvas(800, 600);
    
    expect(processor.canvas.width).toBe(800);
    expect(processor.canvas.height).toBe(600);
    expect(processor.ctx).toBeDefined();
  });

  test('should detect watermark in bright areas', async () => {
    // 创建测试图片数据（包含亮色水印）
    const imageData = createTestImageDataWithWatermark();
    const maskData = await processor.detectWatermark(imageData);
    
    // 验证水印检测区域
    const watermarkArea = getWatermarkArea(maskData);
    expect(watermarkArea).toBeDefined();
    expect(watermarkArea.pixelCount).toBeGreaterThan(0);
  });

  test('should inpaint image using neighboring pixels', async () => {
    const imageData = createTestImageData();
    const maskData = createTestMaskData();
    const resultData = await processor.inpaint(imageData, maskData);
    
    // 验证修复结果
    expect(resultData).toBeDefined();
    expect(resultData.data.length).toBe(imageData.data.length);
    
    // 验证水印区域被修复
    const inpaintedArea = getInpaintedArea(resultData, imageData);
    expect(inpaintedArea.difference).toBeLessThan(50); // 差异阈值
  });

  test('should handle edge cases', async () => {
    // 测试边界情况
    const smallImageData = createSmallImageData();
    const maskData = createTestMaskData();
    
    const resultData = await processor.inpaint(smallImageData, maskData);
    expect(resultData).toBeDefined();
  });
});

// 辅助函数
function createTestImageDataWithWatermark() {
  // 创建包含亮色水印的测试数据
  const width = 100;
  const height = 100;
  const data = new Uint8ClampedArray(width * height * 4);
  
  // 填充基础颜色
  for (let i = 0; i < data.length; i += 4) {
    data[i] = 100;     // R
    data[i + 1] = 100; // G
    data[i + 2] = 100; // B
    data[i + 3] = 255; // A
  }
  
  // 添加亮色水印区域
  for (let y = 40; y < 60; y++) {
    for (let x = 40; x < 60; x++) {
      const idx = (y * width + x) * 4;
      data[idx] = 255;     // R
      data[idx + 1] = 255; // G
      data[idx + 2] = 255; // B
      data[idx + 3] = 255; // A
    }
  }
  
  return new ImageData(data, width, height);
}
```

#### 2. 链接解析测试

```javascript
// tests/unit/link-parser.test.js
import { expect, test } from '@jest/globals';
import LinkParser from '../../utils/link-parser.js';

describe('Link Parser', () => {
  let parser;

  beforeEach(() => {
    parser = new LinkParser();
  });

  test('should detect xiaohongshu platform', () => {
    const url = 'https://www.xiaohongshu.com/explore/123456';
    const platform = parser.detectPlatform(url);
    
    expect(platform).toBeDefined();
    expect(platform.name).toBe('小红书');
  });

  test('should detect douyin platform', () => {
    const url = 'https://www.douyin.com/video/123456';
    const platform = parser.detectPlatform(url);
    
    expect(platform).toBeDefined();
    expect(platform.name).toBe('抖音');
  });

  test('should detect weibo platform', () => {
    const url = 'https://weibo.com/123456/status/7890';
    const platform = parser.detectPlatform(url);
    
    expect(platform).toBeDefined();
    expect(platform.name).toBe('微博');
  });

  test('should return null for unsupported platform', () => {
    const url = 'https://unsupported-platform.com/content';
    const platform = parser.detectPlatform(url);
    
    expect(platform).toBeNull();
  });

  test('should validate image URLs', () => {
    expect(parser.isImageUrl('https://example.com/image.jpg')).toBe(true);
    expect(parser.isImageUrl('https://example.com/image.png')).toBe(true);
    expect(parser.isImageUrl('https://example.com/image.gif')).toBe(true);
    expect(parser.isImageUrl('https://example.com/page.html')).toBe(false);
    expect(parser.isImageUrl('https://example.com/video.mp4')).toBe(false);
  });

  test('should resolve relative URLs', () => {
    const baseUrl = 'https://example.com/page/';
    const relativeUrl = 'image.jpg';
    const resolvedUrl = parser.resolveUrl(relativeUrl, baseUrl);
    
    expect(resolvedUrl).toBe('https://example.com/page/image.jpg');
  });
});
```

#### 3. 存储管理测试

```javascript
// tests/unit/storage-manager.test.js
import { expect, test } from '@jest/globals';
import StorageManager from '../../utils/storage-manager.js';

describe('Storage Manager', () => {
  let storageManager;

  beforeEach(async () => {
    storageManager = new StorageManager();
    await storageManager.initDB();
  });

  afterEach(async () => {
    await storageManager.clearAllData();
  });

  test('should save and retrieve settings', async () => {
    const key = 'test_setting';
    const value = 'test_value';
    
    await storageManager.saveSettings(key, value);
    const retrievedValue = await storageManager.getSettings(key);
    
    expect(retrievedValue).toBe(value);
  });

  test('should save and retrieve history', async () => {
    const historyRecord = {
      type: 'traditional',
      originalPath: '/test/original.jpg',
      resultPath: '/test/result.jpg',
      processingTime: 1000
    };
    
    const savedRecord = await storageManager.saveHistory(historyRecord);
    expect(savedRecord.id).toBeDefined();
    expect(savedRecord.type).toBe('traditional');
    
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(1);
    expect(history.records[0].id).toBe(savedRecord.id);
  });

  test('should delete history record', async () => {
    const historyRecord = {
      type: 'traditional',
      originalPath: '/test/original.jpg',
      resultPath: '/test/result.jpg'
    };
    
    const savedRecord = await storageManager.saveHistory(historyRecord);
    await storageManager.deleteHistory(savedRecord.id);
    
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(0);
  });

  test('should cache and retrieve image data', async () => {
    const url = 'https://example.com/test.jpg';
    const imageData = new Uint8Array([1, 2, 3, 4, 5]);
    
    await storageManager.cacheImage(url, imageData);
    const cachedData = await storageManager.getCachedImage(url);
    
    expect(cachedData).toEqual(imageData);
  });
});
```

### 集成测试

#### 1. 完整流程测试

```javascript
// tests/integration/full-workflow.test.js
import { expect, test } from '@jest/globals';
import ImageProcessor from '../../utils/image-processor.js';
import LinkParser from '../../utils/link-parser.js';
import StorageManager from '../../utils/storage-manager.js';

describe('Full Workflow Integration', () => {
  let imageProcessor;
  let linkParser;
  let storageManager;

  beforeEach(async () => {
    imageProcessor = new ImageProcessor();
    linkParser = new LinkParser();
    storageManager = new StorageManager();
    await storageManager.initDB();
  });

  test('should complete traditional image processing workflow', async () => {
    // 1. 模拟图片上传
    const mockImagePath = '/mock/image.jpg';
    const mockImageData = createMockImageData();
    
    // 2. 处理图片
    const maskData = await imageProcessor.detectWatermark(mockImageData);
    const resultData = await imageProcessor.inpaint(mockImageData, maskData);
    
    // 3. 保存历史记录
    const historyRecord = {
      type: 'traditional',
      originalPath: mockImagePath,
      resultPath: '/mock/result.jpg',
      processingTime: Date.now()
    };
    
    const savedRecord = await storageManager.saveHistory(historyRecord);
    
    // 4. 验证结果
    expect(savedRecord).toBeDefined();
    expect(savedRecord.type).toBe('traditional');
    expect(savedRecord.processingTime).toBeDefined();
    
    // 5. 验证历史记录
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(1);
    expect(history.records[0].id).toBe(savedRecord.id);
  });

  test('should complete link processing workflow', async () => {
    // 1. 模拟链接解析
    const mockUrl = 'https://www.xiaohongshu.com/explore/123456';
    const mockContent = createMockXiaohongshuContent();
    
    // 2. 解析链接（模拟）
    jest.spyOn(linkParser, 'fetchWithProxy').mockResolvedValue(mockContent);
    const parseResult = await linkParser.parseLink(mockUrl);
    
    // 3. 验证解析结果
    expect(parseResult.platform).toBe('小红书');
    expect(parseResult.images).toBeDefined();
    expect(parseResult.images.length).toBeGreaterThan(0);
    
    // 4. 保存历史记录
    const historyRecord = {
      type: 'link',
      originalUrl: mockUrl,
      platform: parseResult.platform,
      images: parseResult.images,
      processingTime: Date.now()
    };
    
    const savedRecord = await storageManager.saveHistory(historyRecord);
    
    // 5. 验证历史记录
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(1);
    expect(history.records[0].platform).toBe('小红书');
  });

  test('should handle errors gracefully', async () => {
    // 测试无效链接处理
    const invalidUrl = 'https://invalid-url.com';
    
    await expect(linkParser.parseLink(invalidUrl)).rejects.toThrow();
    
    // 验证错误情况下不会保存错误数据
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(0);
  });
});
```

### 性能测试

#### 1. 图像处理性能测试

```javascript
// tests/performance/image-processing.test.js
import { expect, test } from '@jest/globals';
import ImageProcessor from '../../utils/image-processor.js';
import PerformanceOptimizer from '../../utils/performance-optimizer.js';

describe('Image Processing Performance', () => {
  let imageProcessor;
  let performanceOptimizer;

  beforeEach(() => {
    imageProcessor = new ImageProcessor();
    performanceOptimizer = new PerformanceOptimizer();
  });

  test('should process small image quickly', async () => {
    const smallImageData = createTestImageData(100, 100);
    const maskData = createTestMaskData(100, 100);
    
    const startTime = performance.now();
    const resultData = await imageProcessor.inpaint(smallImageData, maskData);
    const endTime = performance.now();
    
    const processingTime = endTime - startTime;
    
    expect(resultData).toBeDefined();
    expect(processingTime).toBeLessThan(1000); // 小于1秒
  });

  test('should handle large image without memory issues', async () => {
    const largeImageData = createTestImageData(2000, 2000);
    const maskData = createTestMaskData(2000, 2000);
    
    const startTime = performance.now();
    const resultData = await performanceOptimizer.processLargeImage(largeImageData, 512);
    const endTime = performance.now();
    
    const processingTime = endTime - startTime;
    
    expect(resultData).toBeDefined();
    expect(processingTime).toBeLessThan(5000); // 小于5秒
  });

  test('should compress image efficiently', async () => {
    const largeImageData = createTestImageData(4000, 3000);
    
    const startTime = performance.now();
    const compressedImage = await performanceOptimizer.compressImage(largeImageData, 0.8);
    const endTime = performance.now();
    
    const compressionTime = endTime - startTime;
    
    expect(compressedImage).toBeDefined();
    expect(compressedImage.width).toBeLessThanOrEqual(1920);
    expect(compressedImage.height).toBeLessThanOrEqual(1920);
    expect(compressionTime).toBeLessThan(2000); // 小于2秒
  });
});
```

### 测试覆盖率

```javascript
// jest.config.js
module.exports = {
  preset: 'jest-preset-wechat',
  testEnvironment: 'jsdom',
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/tests/'
  ],
  collectCoverageFrom: [
    'miniprogram/**/*.js',
    'utils/**/*.js',
    '!**/node_modules/**',
    '!**/tests/**'
  ],
  testMatch: [
    '**/tests/**/*.test.js'
  ],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js']
};
```

---

## 运维监控

### 性能监控

#### 1. 前端性能监控

```javascript
// utils/monitoring.js
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      imageProcessing: [],
      linkParsing: [],
      storageOperations: [],
      memoryUsage: []
    };
    this.initMonitoring();
  }

  initMonitoring() {
    // 监控图片处理性能
    this.monitorImageProcessing();
    
    // 监控内存使用
    this.monitorMemoryUsage();
    
    // 监控页面性能
    this.monitorPagePerformance();
  }

  monitorImageProcessing() {
    const originalProcess = ImageProcessor.prototype.inpaint;
    
    ImageProcessor.prototype.inpaint = async function(imageData, maskData) {
      const startTime = performance.now();
      const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
      
      try {
        const result = await originalProcess.call(this, imageData, maskData);
        
        const endTime = performance.now();
        const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
        
        // 记录性能指标
        this.recordMetric('imageProcessing', {
          duration: endTime - startTime,
          memoryUsed: endMemory - startMemory,
          imageSize: imageData.width * imageData.height,
          timestamp: Date.now()
        });
        
        return result;
      } catch (error) {
        this.recordError('imageProcessing', error);
        throw error;
      }
    };
  }

  monitorMemoryUsage() {
    setInterval(() => {
      if (performance.memory) {
        this.recordMetric('memoryUsage', {
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize,
          limit: performance.memory.jsHeapSizeLimit,
          timestamp: Date.now()
        });
      }
    }, 30000); // 每30秒记录一次
  }

  monitorPagePerformance() {
    if (typeof wx !== 'undefined') {
      wx.onMemoryWarning((res) => {
        this.recordMetric('memoryWarning', {
          level: res.level,
          timestamp: Date.now()
        });
      });
    }
  }

  recordMetric(type, data) {
    this.metrics[type].push(data);
    
    // 保持最近1000条记录
    if (this.metrics[type].length > 1000) {
      this.metrics[type] = this.metrics[type].slice(-1000);
    }
    
    // 本地存储关键指标
    this.persistMetrics();
  }

  recordError(type, error) {
    const errorData = {
      message: error.message,
      stack: error.stack,
      timestamp: Date.now()
    };
    
    // 存储错误信息
    const errors = this.getStoredErrors();
    errors.push(errorData);
    
    // 保持最近100条错误记录
    if (errors.length > 100) {
      errors.shift();
    }
    
    wx.setStorageSync('error_logs', errors);
  }

  persistMetrics() {
    try {
      const summary = this.getMetricsSummary();
      wx.setStorageSync('performance_metrics', summary);
    } catch (error) {
      console.error('Failed to persist metrics:', error);
    }
  }

  getMetricsSummary() {
    const summary = {};
    
    for (const [type, metrics] of Object.entries(this.metrics)) {
      if (metrics.length > 0) {
        summary[type] = {
          count: metrics.length,
          avgDuration: this.calculateAverage(metrics.map(m => m.duration)),
          maxDuration: Math.max(...metrics.map(m => m.duration)),
          minDuration: Math.min(...metrics.map(m => m.duration)),
          lastUpdated: Date.now()
        };
      }
    }
    
    return summary;
  }

  calculateAverage(numbers) {
    if (numbers.length === 0) return 0;
    return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  }

  getStoredErrors() {
    try {
      return wx.getStorageSync('error_logs') || [];
    } catch (error) {
      return [];
    }
  }

  getPerformanceReport() {
    return {
      metrics: this.getMetricsSummary(),
      errors: this.getStoredErrors(),
      deviceInfo: this.getDeviceInfo(),
      timestamp: Date.now()
    };
  }

  getDeviceInfo() {
    if (typeof wx !== 'undefined') {
      return {
        system: wx.getSystemInfoSync(),
        platform: 'miniprogram'
      };
    } else {
      return {
        userAgent: navigator.userAgent,
        platform: 'web'
      };
    }
  }

  // 清理旧的监控数据
  cleanup() {
    const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    
    for (const [type, metrics] of Object.entries(this.metrics)) {
      this.metrics[type] = metrics.filter(m => m.timestamp > oneWeekAgo);
    }
    
    this.persistMetrics();
  }
}

export default PerformanceMonitor;
```

#### 2. 错误监控

```javascript
// utils/error-handler.js
class ErrorHandler {
  constructor() {
    this.errorQueue = [];
    this.maxErrors = 50;
    this.initErrorHandling();
  }

  initErrorHandling() {
    // 全局错误处理
    if (typeof wx !== 'undefined') {
      wx.onError((error) => {
        this.handleError(error, 'wx.onError');
      });
      
      wx.onUnhandledRejection((event) => {
        this.handleError(event.reason, 'unhandledRejection');
      });
    } else {
      window.addEventListener('error', (event) => {
        this.handleError(event.error, 'window.error');
      });
      
      window.addEventListener('unhandledrejection', (event) => {
        this.handleError(event.reason, 'unhandledRejection');
      });
    }
  }

  handleError(error, source = 'unknown') {
    const errorData = {
      message: error.message || String(error),
      stack: error.stack || '',
      source: source,
      timestamp: Date.now(),
      userAgent: this.getUserAgent(),
      url: this.getCurrentUrl()
    };

    this.errorQueue.push(errorData);

    // 保持错误队列大小
    if (this.errorQueue.length > this.maxErrors) {
      this.errorQueue.shift();
    }

    // 持久化错误数据
    this.persistErrors();

    // 上报错误（可选）
    this.reportError(errorData);

    // 用户友好的错误提示
    this.showUserFriendlyError(error);
  }

  getUserAgent() {
    if (typeof wx !== 'undefined') {
      const systemInfo = wx.getSystemInfoSync();
      return `${systemInfo.platform} ${systemInfo.system} ${systemInfo.version}`;
    } else {
      return navigator.userAgent;
    }
  }

  getCurrentUrl() {
    if (typeof wx !== 'undefined') {
      const pages = getCurrentPages();
      if (pages.length > 0) {
        return pages[pages.length - 1].route;
      }
      return 'unknown';
    } else {
      return window.location.href;
    }
  }

  persistErrors() {
    try {
      wx.setStorageSync('error_logs', this.errorQueue);
    } catch (error) {
      console.error('Failed to persist errors:', error);
    }
  }

  reportError(errorData) {
    // 这里可以实现错误上报逻辑
    // 例如发送到监控服务或分析平台
    console.log('Error reported:', errorData);
  }

  showUserFriendlyError(error) {
    let userMessage = '操作失败，请重试';

    // 根据错误类型显示用户友好的消息
    if (error.message.includes('network')) {
      userMessage = '网络连接失败，请检查网络设置';
    } else if (error.message.includes('memory')) {
      userMessage = '内存不足，请关闭其他应用后重试';
    } else if (error.message.includes('permission')) {
      userMessage = '没有相应权限，请在设置中开启';
    }

    if (typeof wx !== 'undefined') {
      wx.showToast({
        title: userMessage,
        icon: 'none',
        duration: 3000
      });
    } else {
      alert(userMessage);
    }
  }

  getErrorReport() {
    return {
      errors: this.errorQueue,
      errorCount: this.errorQueue.length,
      lastError: this.errorQueue[this.errorQueue.length - 1],
      timestamp: Date.now()
    };
  }

  clearErrors() {
    this.errorQueue = [];
    this.persistErrors();
  }
}

export default ErrorHandler;
```

### 日志管理

#### 1. 本地日志系统

```javascript
// utils/logger.js
class Logger {
  constructor() {
    this.logs = [];
    this.maxLogs = 1000;
    this.levels = {
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3
    };
    this.currentLevel = this.levels.INFO;
    this.initLogger();
  }

  initLogger() {
    // 从存储中加载日志
    this.loadLogs();
    
    // 设置日志清理定时器
    setInterval(() => this.cleanupLogs(), 24 * 60 * 60 * 1000); // 每天清理一次
  }

  loadLogs() {
    try {
      const storedLogs = wx.getStorageSync('app_logs');
      if (storedLogs) {
        this.logs = storedLogs;
      }
    } catch (error) {
      console.error('Failed to load logs:', error);
    }
  }

  saveLogs() {
    try {
      // 只保存最近的日志
      const recentLogs = this.logs.slice(-this.maxLogs);
      wx.setStorageSync('app_logs', recentLogs);
    } catch (error) {
      console.error('Failed to save logs:', error);
    }
  }

  log(level, message, data = {}) {
    const logEntry = {
      level: level,
      message: message,
      data: data,
      timestamp: Date.now(),
      sessionId: this.getSessionId(),
      userId: this.getUserId()
    };

    this.logs.push(logEntry);

    // 控制台输出
    if (typeof wx !== 'undefined') {
      console.log(`[${level}] ${message}`, data);
    } else {
      console.log(`[${level}] ${message}`, data);
    }

    // 保存日志
    this.saveLogs();

    // 如果是错误级别，同时记录到错误处理器
    if (level === 'ERROR') {
      this.reportError(logEntry);
    }
  }

  debug(message, data = {}) {
    if (this.currentLevel <= this.levels.DEBUG) {
      this.log('DEBUG', message, data);
    }
  }

  info(message, data = {}) {
    if (this.currentLevel <= this.levels.INFO) {
      this.log('INFO', message, data);
    }
  }

  warn(message, data = {}) {
    if (this.currentLevel <= this.levels.WARN) {
      this.log('WARN', message, data);
    }
  }

  error(message, data = {}) {
    if (this.currentLevel <= this.levels.ERROR) {
      this.log('ERROR', message, data);
    }
  }

  getSessionId() {
    let sessionId = wx.getStorageSync('session_id');
    if (!sessionId) {
      sessionId = Date.now().toString();
      wx.setStorageSync('session_id', sessionId);
    }
    return sessionId;
  }

  getUserId() {
    // 如果有用户系统，返回用户ID
    return wx.getStorageSync('user_id') || 'anonymous';
  }

  reportError(logEntry) {
    // 报告错误到监控系统
    if (typeof ErrorHandler !== 'undefined') {
      const errorHandler = new ErrorHandler();
      errorHandler.handleError({
        message: logEntry.message,
        stack: JSON.stringify(logEntry.data)
      }, 'logger');
    }
  }

  getLogs(filters = {}) {
    let filteredLogs = [...this.logs];

    // 按级别过滤
    if (filters.level) {
      filteredLogs = filteredLogs.filter(log => log.level === filters.level);
    }

    // 按时间范围过滤
    if (filters.startTime) {
      filteredLogs = filteredLogs.filter(log => log.timestamp >= filters.startTime);
    }

    if (filters.endTime) {
      filteredLogs = filteredLogs.filter(log => log.timestamp <= filters.endTime);
    }

    // 按关键词过滤
    if (filters.keyword) {
      filteredLogs = filteredLogs.filter(log => 
        log.message.includes(filters.keyword) ||
        JSON.stringify(log.data).includes(filters.keyword)
      );
    }

    return filteredLogs;
  }

  getLogStats() {
    const stats = {
      total: this.logs.length,
      byLevel: {},
      byDay: {},
      recentErrors: []
    };

    // 按级别统计
    for (const [level, count] of Object.entries(this.levels)) {
      stats.byLevel[level] = this.logs.filter(log => log.level === level).length;
    }

    // 按天统计
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    for (let i = 0; i < 7; i++) {
      const day = new Date(today);
      day.setDate(day.getDate() - i);
      const dayStart = day.getTime();
      const dayEnd = dayStart + 24 * 60 * 60 * 1000;
      
      stats.byDay[day.toISOString().split('T')[0]] = this.logs.filter(
        log => log.timestamp >= dayStart && log.timestamp < dayEnd
      ).length;
    }

    // 最近的错误
    stats.recentErrors = this.logs
      .filter(log => log.level === 'ERROR')
      .slice(-10)
      .reverse();

    return stats;
  }

  cleanupLogs() {
    const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    this.logs = this.logs.filter(log => log.timestamp > oneWeekAgo);
    this.saveLogs();
  }

  exportLogs() {
    return {
      logs: this.logs,
      stats: this.getLogStats(),
      exportTime: Date.now(),
      version: '1.0'
    };
  }

  clearLogs() {
    this.logs = [];
    this.saveLogs();
  }

  setLevel(level) {
    if (this.levels.hasOwnProperty(level)) {
      this.currentLevel = this.levels[level];
    }
  }
}

export default Logger;
```

---

## 安全方案

### 数据安全

#### 1. 本地数据加密

```javascript
// utils/crypto.js
class CryptoManager {
  constructor() {
    this.secretKey = this.getOrCreateSecretKey();
  }

  getOrCreateSecretKey() {
    let key = wx.getStorageSync('crypto_secret_key');
    if (!key) {
      // 生成随机密钥
      key = this.generateRandomKey();
      wx.setStorageSync('crypto_secret_key', key);
    }
    return key;
  }

  generateRandomKey() {
    const array = new Uint8Array(32);
    for (let i = 0; i < array.length; i++) {
      array[i] = Math.floor(Math.random() * 256);
    }
    return Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  // 简单的XOR加密
  encrypt(text) {
    const key = this.secretKey;
    let encrypted = '';
    
    for (let i = 0; i < text.length; i++) {
      const charCode = text.charCodeAt(i);
      const keyChar = key.charCodeAt(i % key.length);
      encrypted += String.fromCharCode(charCode ^ keyChar);
    }
    
    return btoa(encrypted); // Base64编码
  }

  decrypt(encryptedText) {
    const key = this.secretKey;
    const decoded = atob(encryptedText); // Base64解码
    let decrypted = '';
    
    for (let i = 0; i < decoded.length; i++) {
      const charCode = decoded.charCodeAt(i);
      const keyChar = key.charCodeAt(i % key.length);
      decrypted += String.fromCharCode(charCode ^ keyChar);
    }
    
    return decrypted;
  }

  // 加密敏感数据
  encryptSensitiveData(data) {
    const sensitiveFields = ['originalPath', 'resultPath', 'url'];
    const encryptedData = { ...data };
    
    for (const field of sensitiveFields) {
      if (encryptedData[field]) {
        encryptedData[field] = this.encrypt(encryptedData[field]);
      }
    }
    
    return encryptedData;
  }

  // 解密敏感数据
  decryptSensitiveData(data) {
    const sensitiveFields = ['originalPath', 'resultPath', 'url'];
    const decryptedData = { ...data };
    
    for (const field of sensitiveFields) {
      if (decryptedData[field]) {
        try {
          decryptedData[field] = this.decrypt(decryptedData[field]);
        } catch (error) {
          console.error('Failed to decrypt field:', field, error);
        }
      }
    }
    
    return decryptedData;
  }
}

export default CryptoManager;
```

#### 2. 隐私保护

```javascript
// utils/privacy.js
class PrivacyManager {
  constructor() {
    this.cryptoManager = new CryptoManager();
    this.anonymizationLevel = this.getAnonymizationLevel();
  }

  getAnonymizationLevel() {
    return wx.getStorageSync('privacy_anonymization_level') || 'basic';
  }

  // 匿名化用户数据
  anonymizeUserData(userData) {
    const anonymizedData = { ...userData };
    
    switch (this.anonymizationLevel) {
      case 'strict':
        // 严格模式：移除所有可识别信息
        delete anonymizedData.userId;
        delete anonymizedData.sessionId;
        delete anonymizedData.deviceId;
        break;
        
      case 'basic':
      default:
        // 基本模式：哈希处理可识别信息
        if (anonymizedData.userId) {
          anonymizedData.userId = this.hashData(anonymizedData.userId);
        }
        if (anonymizedData.deviceId) {
          anonymizedData.deviceId = this.hashData(anonymizedData.deviceId);
        }
        break;
    }
    
    return anonymizedData;
  }

  // 哈希数据
  hashData(data) {
    // 简单的哈希函数
    let hash = 0;
    const str = String(data);
    
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 转换为32位整数
    }
    
    return Math.abs(hash).toString(16);
  }

  // 检查数据是否包含敏感信息
  containsSensitiveInfo(data) {
    const sensitivePatterns = [
      /password/i,
      /token/i,
      /secret/i,
      /key/i,
      /auth/i,
      /credential/i
    ];
    
    const dataString = JSON.stringify(data);
    
    return sensitivePatterns.some(pattern => pattern.test(dataString));
  }

  // 清理敏感数据
  sanitizeData(data) {
    if (typeof data !== 'object' || data === null) {
      return data;
    }
    
    const sanitized = Array.isArray(data) ? [] : {};
    
    for (const [key, value] of Object.entries(data)) {
      if (this.isSensitiveField(key)) {
        sanitized[key] = '[REDACTED]';
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeData(value);
      } else {
        sanitized[key] = value;
      }
    }
    
    return sanitized;
  }

  isSensitiveField(fieldName) {
    const sensitiveFields = [
      'password', 'token', 'secret', 'key', 'auth',
      'credential', 'session', 'cookie', 'authorization'
    ];
    
    return sensitiveFields.some(field => 
      fieldName.toLowerCase().includes(field)
    );
  }

  // 获取隐私政策
  getPrivacyPolicy() {
    return {
      version: '1.0',
      lastUpdated: new Date().toISOString(),
      dataCollection: {
        images: {
          collected: true,
          purpose: '水印去除处理',
          retention: '本地存储，用户可删除',
          sharing: '不与第三方共享'
        },
        links: {
          collected: true,
          purpose: '解析图片链接',
          retention: '临时存储，处理完成后删除',
          sharing: '不与第三方共享'
        },
        usage: {
          collected: true,
          purpose: '改善用户体验',
          retention: '本地存储，用户可删除',
          sharing: '匿名化统计'
        }
      },
      userRights: {
        access: '用户可访问自己的数据',
        rectification: '用户可更正错误数据',
        deletion: '用户可删除自己的数据',
        portability: '用户可导出自己的数据'
      }
    };
  }

  // 用户同意管理
  setUserConsent(consentType, agreed) {
    const consents = this.getUserConsents();
    consents[consentType] = {
      agreed: agreed,
      timestamp: Date.now(),
      version: '1.0'
    };
    
    wx.setStorageSync('privacy_consents', consents);
  }

  getUserConsents() {
    return wx.getStorageSync('privacy_consents') || {};
  }

  hasUserConsent(consentType) {
    const consents = this.getUserConsents();
    return consents[consentType]?.agreed || false;
  }

  // 数据导出
  exportUserData() {
    const userData = {
      history: this.getStoredHistory(),
      settings: this.getStoredSettings(),
      consents: this.getUserConsents(),
      exportTime: new Date().toISOString()
    };
    
    return this.cryptoManager.encryptSensitiveData(userData);
  }

  // 数据删除
  deleteUserData() {
    // 删除所有用户数据
    wx.removeStorageSync('history');
    wx.removeStorageSync('settings');
    wx.removeStorageSync('privacy_consents');
    wx.removeStorageSync('session_id');
    wx.removeStorageSync('user_id');
    
    // 清理缓存
    wx.removeStorageSync('cache');
    
    return true;
  }

  getStoredHistory() {
    try {
      return wx.getStorageSync('history') || [];
    } catch (error) {
      return [];
    }
  }

  getStoredSettings() {
    try {
      return wx.getStorageSync('settings') || {};
    } catch (error) {
      return {};
    }
  }
}

export default PrivacyManager;
```

### 权限管理

#### 1. 权限请求管理

```javascript
// utils/permissions.js
class PermissionManager {
  constructor() {
    this.permissions = {
      'scope.writePhotosAlbum': {
        name: '相册写入权限',
        description: '需要保存处理后的图片到相册',
        required: false
      },
      'scope.camera': {
        name: '相机权限',
        description: '需要使用相机拍照',
        required: false
      },
      'scope.record': {
        name: '录音权限',
        description: '需要录制音频',
        required: false
      },
      'scope.userLocation': {
        name: '位置权限',
        description: '需要获取位置信息',
        required: false
      }
    };
  }

  // 请求权限
  async requestPermission(scope) {
    return new Promise((resolve) => {
      wx.authorize({
        scope: scope,
        success: () => resolve(true),
        fail: () => resolve(false)
      });
    });
  }

  // 检查权限状态
  async checkPermission(scope) {
    return new Promise((resolve) => {
      wx.getSetting({
        success: (res) => {
          const hasPermission = res.authSetting[scope];
          resolve(hasPermission);
        },
        fail: () => resolve(false)
      });
    });
  }

  // 获取权限
  async getPermission(scope) {
    const hasPermission = await this.checkPermission(scope);
    
    if (!hasPermission) {
      const permissionInfo = this.permissions[scope];
      if (permissionInfo) {
        // 显示权限说明
        await this.showPermissionDialog(permissionInfo);
        
        // 请求权限
        const granted = await this.requestPermission(scope);
        
        if (!granted) {
          // 权限被拒绝
          await this.showPermissionDeniedDialog(permissionInfo);
          return false;
        }
      } else {
        return false;
      }
    }
    
    return true;
  }

  // 显示权限说明对话框
  showPermissionDialog(permissionInfo) {
    return new Promise((resolve) => {
      wx.showModal({
        title: '需要权限',
        content: permissionInfo.description,
        confirmText: '去设置',
        cancelText: '取消',
        success: (res) => {
          if (res.confirm) {
            wx.openSetting();
          }
          resolve();
        }
      });
    });
  }

  // 显示权限被拒绝对话框
  showPermissionDeniedDialog(permissionInfo) {
    return new Promise((resolve) => {
      wx.showModal({
        title: '权限被拒绝',
        content: `您拒绝了${permissionInfo.name}，部分功能可能无法正常使用`,
        showCancel: false,
        confirmText: '我知道了',
        success: () => resolve()
      });
    });
  }

  // 请求图片保存权限
  async requestSaveImagePermission() {
    return await this.getPermission('scope.writePhotosAlbum');
  }

  // 请求相机权限
  async requestCameraPermission() {
    return await this.getPermission('scope.camera');
  }

  // 批量请求权限
  async requestMultiplePermissions(scopes) {
    const results = {};
    
    for (const scope of scopes) {
      results[scope] = await this.getPermission(scope);
    }
    
    return results;
  }

  // 检查所有必要权限
  async checkEssentialPermissions() {
    const essentialPermissions = [
      'scope.writePhotosAlbum',
      'scope.camera'
    ];
    
    const results = await this.requestMultiplePermissions(essentialPermissions);
    
    const missingPermissions = Object.entries(results)
      .filter(([_, granted]) => !granted)
      .map(([scope, _]) => scope);
    
    if (missingPermissions.length > 0) {
      console.warn('Missing essential permissions:', missingPermissions);
    }
    
    return {
      allGranted: missingPermissions.length === 0,
      granted: Object.entries(results).filter(([_, granted]) => granted).map(([scope, _]) => scope),
      missing: missingPermissions
    };
  }
}

export default PermissionManager;
```

### 安全审计

#### 1. 安全审计日志

```javascript
// utils/security-audit.js
class SecurityAudit {
  constructor() {
    this.auditLogs = [];
    this.maxLogs = 500;
    this.initAudit();
  }

  initAudit() {
    this.loadAuditLogs();
    
    // 监听敏感操作
    this.monitorSensitiveOperations();
  }

  loadAuditLogs() {
    try {
      const storedLogs = wx.getStorageSync('security_audit_logs');
      if (storedLogs) {
        this.auditLogs = storedLogs;
      }
    } catch (error) {
      console.error('Failed to load audit logs:', error);
    }
  }

  saveAuditLogs() {
    try {
      // 只保存最近的审计日志
      const recentLogs = this.auditLogs.slice(-this.maxLogs);
      wx.setStorageSync('security_audit_logs', recentLogs);
    } catch (error) {
      console.error('Failed to save audit logs:', error);
    }
  }

  monitorSensitiveOperations() {
    // 监听文件操作
    this.monitorFileOperations();
    
    // 监听权限请求
    this.monitorPermissionRequests();
    
    // 监听数据存储操作
    this.monitorDataOperations();
  }

  monitorFileOperations() {
    const originalSaveImage = wx.saveImageToPhotosAlbum;
    const self = this;
    
    wx.saveImageToPhotosAlbum = function(options) {
      self.logAudit({
        action: 'SAVE_IMAGE',
        filePath: options.filePath,
        timestamp: Date.now()
      });
      
      return originalSaveImage.call(this, options);
    };
  }

  monitorPermissionRequests() {
    const originalAuthorize = wx.authorize;
    const self = this;
    
    wx.authorize = function(options) {
      self.logAudit({
        action: 'REQUEST_PERMISSION',
        scope: options.scope,
        timestamp: Date.now()
      });
      
      return originalAuthorize.call(this, options);
    };
  }

  monitorDataOperations() {
    // 监控数据存储操作
    const originalSetStorage = wx.setStorageSync;
    const self = this;
    
    wx.setStorageSync = function(key, data) {
      if (self.isSensitiveKey(key)) {
        self.logAudit({
          action: 'STORE_SENSITIVE_DATA',
          key: key,
          dataSize: JSON.stringify(data).length,
          timestamp: Date.now()
        });
      }
      
      return originalSetStorage.call(this, key, data);
    };
  }

  isSensitiveKey(key) {
    const sensitiveKeys = [
      'user', 'auth', 'token', 'password',
      'secret', 'key', 'credential'
    ];
    
    return sensitiveKeys.some(sensitiveKey => 
      key.toLowerCase().includes(sensitiveKey)
    );
  }

  logAudit(auditEvent) {
    const auditLog = {
      id: this.generateAuditId(),
      sessionId: this.getSessionId(),
      userId: this.getUserId(),
      ...auditEvent,
      deviceInfo: this.getDeviceInfo()
    };

    this.auditLogs.push(auditLog);
    this.saveAuditLogs();
  }

  generateAuditId() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
  }

  getSessionId() {
    return wx.getStorageSync('session_id') || 'unknown';
  }

  getUserId() {
    return wx.getStorageSync('user_id') || 'anonymous';
  }

  getDeviceInfo() {
    try {
      return wx.getSystemInfoSync();
    } catch (error) {
      return {};
    }
  }

  // 获取审计报告
  getAuditReport(filters = {}) {
    let filteredLogs = [...this.auditLogs];

    // 按时间过滤
    if (filters.startTime) {
      filteredLogs = filteredLogs.filter(log => log.timestamp >= filters.startTime);
    }

    if (filters.endTime) {
      filteredLogs = filteredLogs.filter(log => log.timestamp <= filters.endTime);
    }

    // 按操作类型过滤
    if (filters.action) {
      filteredLogs = filteredLogs.filter(log => log.action === filters.action);
    }

    // 按用户过滤
    if (filters.userId) {
      filteredLogs = filteredLogs.filter(log => log.userId === filters.userId);
    }

    return {
      logs: filteredLogs,
      summary: this.generateAuditSummary(filteredLogs),
      filters: filters,
      generatedAt: Date.now()
    };
  }

  generateAuditSummary(logs) {
    const summary = {
      total: logs.length,
      byAction: {},
      byUser: {},
      byTime: {},
      suspiciousActivities: []
    };

    // 按操作类型统计
    logs.forEach(log => {
      summary.byAction[log.action] = (summary.byAction[log.action] || 0) + 1;
    });

    // 按用户统计
    logs.forEach(log => {
      summary.byUser[log.userId] = (summary.byUser[log.userId] || 0) + 1;
    });

    // 按时间统计
    const now = Date.now();
    const oneHourAgo = now - 60 * 60 * 1000;
    const oneDayAgo = now - 24 * 60 * 60 * 1000;

    summary.byTime = {
      lastHour: logs.filter(log => log.timestamp > oneHourAgo).length,
      lastDay: logs.filter(log => log.timestamp > oneDayAgo).length,
      older: logs.filter(log => log.timestamp <= oneDayAgo).length
    };

    // 检测可疑活动
    summary.suspiciousActivities = this.detectSuspiciousActivities(logs);

    return summary;
  }

  detectSuspiciousActivities(logs) {
    const suspicious = [];
    
    // 检测频繁的权限请求
    const permissionRequests = logs.filter(log => log.action === 'REQUEST_PERMISSION');
    const recentPermissionRequests = permissionRequests.filter(
      log => Date.now() - log.timestamp < 5 * 60 * 1000
    );
    
    if (recentPermissionRequests.length > 5) {
      suspicious.push({
        type: 'EXCESSIVE_PERMISSION_REQUESTS',
        count: recentPermissionRequests.length,
        timeWindow: '5分钟'
      });
    }

    // 检测大量的敏感数据存储
    const sensitiveDataOps = logs.filter(log => log.action === 'STORE_SENSITIVE_DATA');
    const largeDataOps = sensitiveDataOps.filter(log => log.dataSize > 10000);
    
    if (largeDataOps.length > 3) {
      suspicious.push({
        type: 'LARGE_SENSITIVE_DATA_STORAGE',
        count: largeDataOps.length,
        avgSize: largeDataOps.reduce((sum, op) => sum + op.dataSize, 0) / largeDataOps.length
      });
    }

    return suspicious;
  }

  // 清理旧的审计日志
  cleanupAuditLogs() {
    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
    this.auditLogs = this.auditLogs.filter(log => log.timestamp > thirtyDaysAgo);
    this.saveAuditLogs();
  }

  // 导出审计日志
  exportAuditLogs() {
    return {
      logs: this.auditLogs,
      exportTime: Date.now(),
      version: '1.0'
    };
  }

  // 清除审计日志
  clearAuditLogs() {
    this.auditLogs = [];
    this.saveAuditLogs();
  }
}

export default SecurityAudit;
```

---

## 总结

### 项目优势

1. **完全前端**：无需后端服务器，降低开发和维护成本
2. **隐私保护**：所有处理在用户设备上完成，数据不上传第三方服务器
3. **高性能**：使用WebWorker和WebAssembly提升处理性能
4. **离线可用**：支持离线使用，网络依赖性低
5. **跨平台**：同时支持小程序和Web版本

### 技术特色

1. **纯前端图像处理**：基于Canvas API和自定义算法
2. **智能链接解析**：支持多平台链接的纯前端解析
3. **本地数据存储**：IndexedDB + LocalStorage的完整存储方案
4. **性能优化**：WebWorker + 分块处理 + 缓存机制
5. **安全防护**：数据加密 + 权限管理 + 安全审计

### 开发建议

1. **迭代开发**：先实现基础功能，再逐步优化
2. **性能测试**：重点关注大图片处理的性能表现
3. **用户体验**：提供实时反馈和进度显示
4. **错误处理**：完善的错误处理和用户引导
5. **隐私保护**：严格保护用户数据安全

这个纯前端去水印小程序方案提供了一个完整的技术架构，可以在没有后端服务器的情况下实现功能完整的去水印工具。
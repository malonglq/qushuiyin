# å»æ°´å°å°ç¨‹åºé¡¹ç›®æŠ€æœ¯æ–‡æ¡£ï¼ˆçº¯å‰ç«¯æ–¹æ¡ˆï¼‰

## é¡¹ç›®æ¦‚è¿°

### é¡¹ç›®èƒŒæ™¯
éšç€ç¤¾äº¤åª’ä½“å’Œå†…å®¹åˆ›ä½œçš„å¿«é€Ÿå‘å±•ï¼Œç”¨æˆ·ç»å¸¸éœ€è¦å¤„ç†å¸¦æœ‰æ°´å°çš„å›¾ç‰‡ã€‚ç°æœ‰çš„å»æ°´å°å·¥å…·å­˜åœ¨æ“ä½œå¤æ‚ã€å¤„ç†æ•ˆæœä¸ä½³ã€éšç§å®‰å…¨ç­‰é—®é¢˜ã€‚æœ¬é¡¹ç›®æ—¨åœ¨å¼€å‘ä¸€ä¸ª**çº¯å‰ç«¯**çš„æ™ºèƒ½ã€é«˜æ•ˆã€å®‰å…¨çš„å»æ°´å°å°ç¨‹åºï¼Œæ‰€æœ‰å¤„ç†éƒ½åœ¨ç”¨æˆ·è®¾å¤‡ä¸Šå®Œæˆï¼Œå®Œå…¨ä¿æŠ¤ç”¨æˆ·éšç§ã€‚

### é¡¹ç›®ç›®æ ‡
- **æŠ€æœ¯ç›®æ ‡**ï¼šæ„å»ºä¸€ä¸ªåŸºäºçº¯å‰ç«¯çš„å»æ°´å°å·¥å…·ï¼Œæ”¯æŒä¼ ç»Ÿä¸Šä¼ å’Œé“¾æ¥è¯»å–ä¸¤ç§æ¨¡å¼
- **æ€§èƒ½ç›®æ ‡**ï¼šå•å¼ å›¾ç‰‡å¤„ç†æ—¶é—´ < 5ç§’ï¼Œæ‰¹é‡å¤„ç†æ”¯æŒå¤šå¼ å›¾ç‰‡
- **ç”¨æˆ·ä½“éªŒç›®æ ‡**ï¼šæ“ä½œæ­¥éª¤ â‰¤ 3æ­¥ï¼Œæ”¯æŒä¸€é”®æ™ºèƒ½è¯†åˆ«å’Œå¤„ç†
- **éšç§ç›®æ ‡**ï¼šæ‰€æœ‰å¤„ç†åœ¨æœ¬åœ°å®Œæˆï¼Œæ•°æ®ä¸ä¸Šä¼ ä»»ä½•æœåŠ¡å™¨
- **æˆæœ¬ç›®æ ‡**ï¼šé›¶æœåŠ¡å™¨æˆæœ¬ï¼Œæ— éœ€åç«¯ç»´æŠ¤

### æŠ€æœ¯æ ˆæ€»è§ˆ
- **å‰ç«¯**ï¼šå¾®ä¿¡åŸç”Ÿå°ç¨‹åº (WXML/WXSS/JavaScript)
- **å›¾åƒå¤„ç†**ï¼šCanvas API + WebAssembly + OpenCV.js
- **æ•°æ®å­˜å‚¨**ï¼šIndexedDB + LocalStorage
- **æ€§èƒ½ä¼˜åŒ–**ï¼šWebWorker + åˆ†å—å¤„ç† + æ¸è¿›å¼åŠ è½½
- **é“¾æ¥è§£æ**ï¼šå‰ç«¯JavaScript + CORSä»£ç†
- **éƒ¨ç½²**ï¼šå¾®ä¿¡å°ç¨‹åºç›´æ¥å‘å¸ƒ

---

## æŠ€æœ¯é€‰å‹åˆ†æ

### å‰ç«¯æŠ€æœ¯é€‰å‹

#### å¾®ä¿¡åŸç”Ÿå°ç¨‹åº
**é€‰æ‹©ç†ç”±ï¼š**
- ç”¨æˆ·åŸºæ•°åºå¤§ï¼Œæ— éœ€é¢å¤–ä¸‹è½½å®‰è£…
- åŸç”Ÿæ€§èƒ½æœ€ä½³ï¼Œç”¨æˆ·ä½“éªŒæµç•…
- å®Œå–„çš„æœ¬åœ°å­˜å‚¨å’Œæ–‡ä»¶ç³»ç»ŸAPI
- ä¸°å¯Œçš„APIæ”¯æŒï¼ˆç›¸æœºã€ç›¸å†Œã€å‰ªè´´æ¿ç­‰ï¼‰

**æŠ€æœ¯ä¼˜åŠ¿ï¼š**
- æ¥è¿‘åŸç”Ÿåº”ç”¨çš„æ€§èƒ½
- å®Œæ•´çš„å¾®ä¿¡ç”Ÿæ€é›†æˆ
- ä¸°å¯Œçš„UIç»„ä»¶å’ŒAPI
- å®Œå–„çš„å¼€å‘å·¥å…·é“¾

#### å›¾åƒå¤„ç†æŠ€æœ¯é€‰å‹

##### Canvas API + è‡ªå®šä¹‰ç®—æ³•
**é€‰æ‹©ç†ç”±ï¼š**
- å¾®ä¿¡å°ç¨‹åºåŸç”Ÿæ”¯æŒ
- æ— éœ€é¢å¤–ä¾èµ–
- å¤„ç†é€Ÿåº¦å¿«
- å¯æ§æ€§å¼º

**æ ¸å¿ƒç®—æ³•ï¼š**
```javascript
// åŸºäºé‚»åŸŸåƒç´ çš„å›¾åƒä¿®å¤ç®—æ³•
async function inpaint(imageData, maskData) {
  const { width, height, data } = imageData;
  const result = new Uint8ClampedArray(data.length);
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const idx = (y * width + x) * 4;
      
      if (maskData[idx] > 0) {
        // è·å–å‘¨å›´åƒç´ å¹³å‡å€¼è¿›è¡Œä¿®å¤
        const neighbors = getNeighbors(data, x, y, width, height);
        const avgR = neighbors.reduce((sum, n) => sum + n.r, 0) / neighbors.length;
        const avgG = neighbors.reduce((sum, n) => sum + n.g, 0) / neighbors.length;
        const avgB = neighbors.reduce((sum, n) => sum + n.b, 0) / neighbors.length;
        
        result[idx] = avgR;
        result[idx + 1] = avgG;
        result[idx + 2] = avgB;
        result[idx + 3] = 255;
      } else {
        result[idx] = data[idx];
        result[idx + 1] = data[idx + 1];
        result[idx + 2] = data[idx + 2];
        result[idx + 3] = data[idx + 3];
      }
    }
  }
  
  return new ImageData(result, width, height);
}
```

##### WebAssembly + OpenCV.js
**é€‰æ‹©ç†ç”±ï¼š**
- é«˜æ€§èƒ½å›¾åƒå¤„ç†
- æˆç†Ÿçš„è®¡ç®—æœºè§†è§‰ç®—æ³•
- æ¥è¿‘åŸç”Ÿæ€§èƒ½
- ä¸°å¯Œçš„å›¾åƒå¤„ç†åŠŸèƒ½

**å®ç°æ–¹æ¡ˆï¼š**
```javascript
// åŠ è½½OpenCV.js
async function loadOpenCV() {
  return new Promise((resolve) => {
    const script = document.createElement('script');
    script.src = 'https://docs.opencv.org/master/opencv.js';
    script.onload = resolve;
    document.head.appendChild(script);
  });
}

// ä½¿ç”¨OpenCVè¿›è¡Œå›¾åƒä¿®å¤
async function cvInpaint(imageData, maskData) {
  await loadOpenCV();
  
  let src = cv.matFromImageData(imageData);
  let mask = cv.matFromImageData(maskData);
  let dst = new cv.Mat();
  
  cv.inpaint(src, mask, dst, 3, cv.INPAINT_TELEA);
  
  return dst;
}
```

#### æ•°æ®å­˜å‚¨æŠ€æœ¯é€‰å‹

##### IndexedDB
**é€‰æ‹©ç†ç”±ï¼š**
- å¤§å®¹é‡æœ¬åœ°å­˜å‚¨
- æ”¯æŒå¤æ‚æ•°æ®ç»“æ„
- å¼‚æ­¥æ“ä½œï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
- å®Œå–„çš„äº‹åŠ¡æ”¯æŒ

**å®ç°æ–¹æ¡ˆï¼š**
```javascript
class StorageManager {
  constructor() {
    this.dbName = 'WatermarkRemoverDB';
    this.version = 1;
    this.db = null;
    this.initDB();
  }

  async initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // åˆ›å»ºå†å²è®°å½•å­˜å‚¨
        if (!db.objectStoreNames.contains('history')) {
          const historyStore = db.createObjectStore('history', {
            keyPath: 'id',
            autoIncrement: true
          });
          historyStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
        
        // åˆ›å»ºè®¾ç½®å­˜å‚¨
        if (!db.objectStoreNames.contains('settings')) {
          db.createObjectStore('settings', { keyPath: 'key' });
        }
        
        // åˆ›å»ºç¼“å­˜å­˜å‚¨
        if (!db.objectStoreNames.contains('cache')) {
          const cacheStore = db.createObjectStore('cache', { keyPath: 'url' });
          cacheStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }

  async saveHistory(record) {
    const transaction = this.db.transaction(['history'], 'readwrite');
    const store = transaction.objectStore('history');
    
    const historyRecord = {
      ...record,
      id: Date.now().toString(),
      timestamp: new Date().toISOString()
    };
    
    return new Promise((resolve, reject) => {
      const request = store.add(historyRecord);
      request.onsuccess = () => resolve(historyRecord);
      request.onerror = () => reject(request.error);
    });
  }
}
```

##### LocalStorage
**é€‰æ‹©ç†ç”±ï¼š**
- ç®€å•æ˜“ç”¨
- åŒæ­¥æ“ä½œ
- é€‚åˆå­˜å‚¨å°‘é‡æ•°æ®
- å…¼å®¹æ€§å¥½

**ä½¿ç”¨åœºæ™¯ï¼š**
- ç”¨æˆ·è®¾ç½®
- åº”ç”¨çŠ¶æ€
- ç¼“å­˜æ•°æ®

### é“¾æ¥è§£ææŠ€æœ¯é€‰å‹

#### å‰ç«¯JavaScriptè§£æ
**é€‰æ‹©ç†ç”±ï¼š**
- å®Œå…¨å‰ç«¯å®ç°
- æ— éœ€åç«¯æ”¯æŒ
- å®æ—¶å¤„ç†
- éšç§ä¿æŠ¤

**å®ç°æ–¹æ¡ˆï¼š**
```javascript
class LinkParser {
  constructor() {
    this.platforms = {
      xiaohongshu: {
        name: 'å°çº¢ä¹¦',
        patterns: [
          /xiaohongshu\.com\/explore\/.+/,
          /xhslink\.com\/.+/,
          /xiaohongshu\.com\/discovery\/item\/.+/
        ],
        parser: this.parseXiaohongshu.bind(this)
      },
      douyin: {
        name: 'æŠ–éŸ³',
        patterns: [
          /douyin\.com\/video\/.+/,
          /iesdouyin\.com\/share\/video\/.+/,
          /v\.douyin\.com\/.+/
        ],
        parser: this.parseDouyin.bind(this)
      },
      weibo: {
        name: 'å¾®åš',
        patterns: [
          /weibo\.com\/.+/,
          /m\.weibo\.cn\/.+/
        ],
        parser: this.parseWeibo.bind(this)
      },
      wechat: {
        name: 'å¾®ä¿¡',
        patterns: [
          /mp\.weixin\.qq\.com\/.+/,
          /weixin\.qq\.com\/.+/
        ],
        parser: this.parseWechat.bind(this)
      }
    };
  }

  async parseLink(url) {
    try {
      const platform = this.detectPlatform(url);
      
      if (!platform) {
        throw new Error('ä¸æ”¯æŒçš„å¹³å°æˆ–é“¾æ¥æ ¼å¼');
      }

      // ä½¿ç”¨CORSä»£ç†è·å–å†…å®¹
      const content = await this.fetchWithProxy(url);
      
      // è§£æå›¾ç‰‡é“¾æ¥
      const images = await platform.parser(content, url);
      
      return {
        platform: platform.name,
        url: url,
        images: images,
        timestamp: Date.now()
      };
    } catch (error) {
      console.error('é“¾æ¥è§£æå¤±è´¥:', error);
      throw error;
    }
  }

  async fetchWithProxy(url) {
    // ä½¿ç”¨å…¬å…±CORSä»£ç†
    const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
    
    try {
      const response = await fetch(proxyUrl, {
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return await response.text();
    } catch (error) {
      // å°è¯•å¤‡ç”¨ä»£ç†
      return await this.fetchWithAlternativeProxy(url);
    }
  }

  async parseXiaohongshu(content, url) {
    const images = [];
    const parser = new DOMParser();
    const doc = parser.parseFromString(content, 'text/html');
    
    // æå–å›¾ç‰‡é“¾æ¥
    const imgElements = doc.querySelectorAll('img');
    imgElements.forEach(img => {
      const src = img.src || img.dataset.src;
      if (src && this.isImageUrl(src)) {
        images.push({
          url: this.resolveUrl(src, url),
          thumbnail: this.getThumbnailUrl(src),
          width: img.naturalWidth,
          height: img.naturalHeight
        });
      }
    });

    return images;
  }

  isImageUrl(url) {
    return /\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(url);
  }

  resolveUrl(url, baseUrl) {
    try {
      return new URL(url, baseUrl).href;
    } catch (e) {
      return url;
    }
  }
}
```

---

## æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    çº¯å‰ç«¯æ¶æ„                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚   å¾®ä¿¡å°ç¨‹åº     â”‚    â”‚   æµè§ˆå™¨ç‰ˆæœ¬     â”‚               â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚               â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚               â”‚
â”‚  â”‚  â”‚   UIå±‚    â”‚  â”‚    â”‚  â”‚   UIå±‚    â”‚  â”‚               â”‚
â”‚  â”‚  â”‚  WXML/WXSS â”‚  â”‚    â”‚  â”‚  HTML/CSS â”‚  â”‚               â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚               â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚               â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚               â”‚
â”‚  â”‚  â”‚   é€»è¾‘å±‚   â”‚  â”‚    â”‚  â”‚   é€»è¾‘å±‚   â”‚  â”‚               â”‚
â”‚  â”‚  â”‚ JavaScript â”‚  â”‚    â”‚  â”‚ JavaScript â”‚  â”‚               â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚               â”‚
â”‚  â”‚                 â”‚    â”‚                 â”‚               â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚               â”‚
â”‚  â”‚  â”‚   å¤„ç†å±‚   â”‚  â”‚    â”‚  â”‚   å¤„ç†å±‚   â”‚  â”‚               â”‚
â”‚  â”‚  â”‚ WebWorker  â”‚  â”‚    â”‚  â”‚ WebWorker  â”‚  â”‚               â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ ¸å¿ƒç®—æ³•å±‚                                â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   å›¾åƒå¤„ç†      â”‚  â”‚   é“¾æ¥è§£æ      â”‚  â”‚   æ•°æ®å­˜å‚¨   â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚             â”‚ â”‚
â”‚  â”‚  Canvas API    â”‚  â”‚  è·¨åŸŸä»£ç†      â”‚  â”‚  IndexedDB   â”‚ â”‚
â”‚  â”‚  WebAssembly   â”‚  â”‚  DOMè§£æ       â”‚  â”‚ LocalStorageâ”‚ â”‚
â”‚  â”‚  OpenCV.js     â”‚  â”‚  æ­£åˆ™è¡¨è¾¾å¼     â”‚  â”‚  ç¼“å­˜ç®¡ç†    â”‚ â”‚
â”‚  â”‚  çº¯JSç®—æ³•      â”‚  â”‚  å¹³å°è¯†åˆ«      â”‚  â”‚  æ•°æ®åŒæ­¥    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—è®¾è®¡

#### 1. æ ¸å¿ƒå¤„ç†æ¨¡å—

```javascript
// /utils/image-processor.js
class ImageProcessor {
  constructor() {
    this.canvas = null;
    this.ctx = null;
  }

  // åˆå§‹åŒ–Canvas
  initCanvas(width, height) {
    this.canvas = document.createElement('canvas');
    this.canvas.width = width;
    this.canvas.height = height;
    this.ctx = this.canvas.getContext('2d');
  }

  // æ°´å°æ£€æµ‹
  async detectWatermark(imageData) {
    const { width, height, data } = imageData;
    const mask = new Uint8ClampedArray(width * height * 4);
    
    // ç®€å•çš„æ°´å°æ£€æµ‹ç®—æ³•
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        
        // æ£€æµ‹äº®è‰²æ°´å°
        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        const isWatermark = brightness > 200; // é˜ˆå€¼å¯è°ƒ
        
        if (isWatermark) {
          mask[idx] = 255;
          mask[idx + 1] = 255;
          mask[idx + 2] = 255;
          mask[idx + 3] = 255;
        }
      }
    }
    
    return new ImageData(mask, width, height);
  }

  // å›¾åƒä¿®å¤
  async inpaint(imageData, maskData) {
    const { width, height, data } = imageData;
    const result = new Uint8ClampedArray(data.length);
    
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = (y * width + x) * 4;
        
        if (maskData[idx] > 0) {
          // è·å–å‘¨å›´åƒç´ å¹³å‡å€¼è¿›è¡Œä¿®å¤
          const neighbors = this.getNeighbors(data, x, y, width, height);
          const avgR = neighbors.reduce((sum, n) => sum + n.r, 0) / neighbors.length;
          const avgG = neighbors.reduce((sum, n) => sum + n.g, 0) / neighbors.length;
          const avgB = neighbors.reduce((sum, n) => sum + n.b, 0) / neighbors.length;
          
          result[idx] = avgR;
          result[idx + 1] = avgG;
          result[idx + 2] = avgB;
          result[idx + 3] = 255;
        } else {
          result[idx] = data[idx];
          result[idx + 1] = data[idx + 1];
          result[idx + 2] = data[idx + 2];
          result[idx + 3] = data[idx + 3];
        }
      }
    }
    
    return new ImageData(result, width, height);
  }

  // è·å–å‘¨å›´åƒç´ 
  getNeighbors(data, x, y, width, height) {
    const neighbors = [];
    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];

    for (const [dx, dy] of directions) {
      const nx = x + dx;
      const ny = y + dy;
      
      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
        const idx = (ny * width + nx) * 4;
        neighbors.push({
          r: data[idx],
          g: data[idx + 1],
          b: data[idx + 2]
        });
      }
    }
    
    return neighbors;
  }
}
```

#### 2. æ€§èƒ½ä¼˜åŒ–æ¨¡å—

```javascript
// /utils/performance-optimizer.js
class PerformanceOptimizer {
  constructor() {
    this.workerPool = [];
    this.maxWorkers = navigator.hardwareConcurrency || 4;
    this.initWorkerPool();
  }

  // åˆå§‹åŒ–Workeræ± 
  initWorkerPool() {
    for (let i = 0; i < this.maxWorkers; i++) {
      const worker = new Worker('/workers/image-processor.worker.js');
      this.workerPool.push({
        worker: worker,
        busy: false
      });
    }
  }

  // åˆ†å—å¤„ç†å¤§å›¾ç‰‡
  async processLargeImage(imageData, blockSize = 512) {
    const { width, height, data } = imageData;
    const result = new Uint8ClampedArray(data.length);
    
    // åˆ†å—å¤„ç†
    for (let y = 0; y < height; y += blockSize) {
      for (let x = 0; x < width; x += blockSize) {
        const blockWidth = Math.min(blockSize, width - x);
        const blockHeight = Math.min(blockSize, height - y);
        
        // æå–å—æ•°æ®
        const blockData = this.extractBlock(data, x, y, blockWidth, blockHeight, width);
        
        // å¤„ç†å—
        const processedBlock = await this.processBlock(blockData, blockWidth, blockHeight);
        
        // åˆå¹¶ç»“æœ
        this.mergeBlock(result, processedBlock, x, y, blockWidth, blockHeight, width);
      }
    }
    
    return new ImageData(result, width, height);
  }

  // å›¾ç‰‡å‹ç¼©
  async compressImage(imageData, quality = 0.8) {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
      const maxSize = 1920;
      let { width, height } = imageData;
      
      if (width > maxSize || height > maxSize) {
        const ratio = Math.min(maxSize / width, maxSize / height);
        width *= ratio;
        height *= ratio;
      }
      
      canvas.width = width;
      canvas.height = height;
      
      // ç»˜åˆ¶å‹ç¼©åçš„å›¾ç‰‡
      ctx.drawImage(imageData, 0, 0, width, height);
      
      // è½¬æ¢ä¸ºBlob
      canvas.toBlob((blob) => {
        resolve({
          blob: blob,
          width: width,
          height: height
        });
      }, 'image/jpeg', quality);
    });
  }
}
```

### æ•°æ®æµè®¾è®¡

```
ç”¨æˆ·è¾“å…¥ â†’ å›¾ç‰‡/é“¾æ¥ â†’ é¢„å¤„ç† â†’ æ°´å°æ£€æµ‹ â†’ å›¾åƒä¿®å¤ â†’ ç»“æœè¾“å‡º â†’ æœ¬åœ°å­˜å‚¨
    â†“         â†“         â†“          â†“          â†“          â†“          â†“
  UIå±‚    â†’  å¤„ç†å±‚   â†’  ç¼“å­˜å±‚   â†’  ç®—æ³•å±‚   â†’  ä¼˜åŒ–å±‚   â†’  è¾“å‡ºå±‚   â†’  å­˜å‚¨å±‚
```

### çŠ¶æ€ç®¡ç†

```javascript
// /utils/state-manager.js
class StateManager {
  constructor() {
    this.state = {
      processing: false,
      progress: 0,
      currentStep: 1,
      images: [],
      settings: {
        quality: 'high',
        autoSave: true,
        batchProcessing: true
      }
    };
    this.listeners = [];
  }

  // æ›´æ–°çŠ¶æ€
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notifyListeners();
  }

  // è·å–çŠ¶æ€
  getState() {
    return this.state;
  }

  // æ·»åŠ ç›‘å¬å™¨
  addListener(callback) {
    this.listeners.push(callback);
  }

  // é€šçŸ¥ç›‘å¬å™¨
  notifyListeners() {
    this.listeners.forEach(callback => callback(this.state));
  }
}
```

---

## APIæ¥å£è®¾è®¡

### å†…éƒ¨APIè®¾è®¡

#### 1. å›¾åƒå¤„ç†API

```javascript
// /api/image-processor.js
class ImageProcessorAPI {
  constructor() {
    this.processor = new ImageProcessor();
    this.optimizer = new PerformanceOptimizer();
  }

  // å¤„ç†å•å¼ å›¾ç‰‡
  async processImage(imagePath, options = {}) {
    try {
      // è·å–å›¾ç‰‡ä¿¡æ¯
      const imageInfo = await this.getImageInfo(imagePath);
      
      // å‹ç¼©å›¾ç‰‡
      const compressedImage = await this.optimizer.compressImage(imageInfo);
      
      // åˆ›å»ºCanvas
      const canvas = await this.createCanvas(compressedImage.width, compressedImage.height);
      const ctx = canvas.getContext('2d');
      
      // ç»˜åˆ¶å›¾ç‰‡
      await this.drawImage(ctx, compressedImage, compressedImage.width, compressedImage.height);
      
      // è·å–å›¾ç‰‡æ•°æ®
      const imageData = ctx.getImageData(0, 0, compressedImage.width, compressedImage.height);
      
      // æ£€æµ‹æ°´å°
      const maskData = await this.processor.detectWatermark(imageData);
      
      // å»é™¤æ°´å°
      const resultData = await this.processor.inpaint(imageData, maskData);
      
      // ä¿å­˜ç»“æœ
      const resultPath = await this.saveResultImage(canvas, resultData);
      
      return {
        success: true,
        resultPath: resultPath,
        originalPath: imagePath,
        processingTime: Date.now()
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // æ‰¹é‡å¤„ç†å›¾ç‰‡
  async batchProcessImages(imagePaths, options = {}) {
    const results = [];
    
    for (let i = 0; i < imagePaths.length; i++) {
      const imagePath = imagePaths[i];
      
      try {
        const result = await this.processImage(imagePath, options);
        results.push(result);
        
        // æ›´æ–°è¿›åº¦
        this.updateProgress({
          current: i + 1,
          total: imagePaths.length,
          progress: ((i + 1) / imagePaths.length) * 100
        });
        
      } catch (error) {
        results.push({
          success: false,
          error: error.message,
          imagePath: imagePath
        });
      }
    }
    
    return results;
  }
}
```

#### 2. é“¾æ¥è§£æAPI

```javascript
// /api/link-parser.js
class LinkParserAPI {
  constructor() {
    this.parser = new LinkParser();
  }

  // è§£æé“¾æ¥
  async parseLink(url) {
    try {
      const result = await this.parser.parseLink(url);
      
      return {
        success: true,
        data: result
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // æ‰¹é‡è§£æé“¾æ¥
  async batchParseLinks(urls) {
    const results = [];
    
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      
      try {
        const result = await this.parseLink(url);
        results.push(result);
        
      } catch (error) {
        results.push({
          success: false,
          error: error.message,
          url: url
        });
      }
    }
    
    return results;
  }

  // è·å–æ”¯æŒçš„å¹³å°
  getSupportedPlatforms() {
    return [
      { name: 'å°çº¢ä¹¦', icon: 'ğŸ“•', color: '#fe2c55' },
      { name: 'æŠ–éŸ³', icon: 'ğŸ“±', color: '#000000' },
      { name: 'å¾®åš', icon: 'ğŸŒ', color: '#e6162d' },
      { name: 'å¾®ä¿¡', icon: 'ğŸ“–', color: '#07c160' }
    ];
  }
}
```

#### 3. å­˜å‚¨ç®¡ç†API

```javascript
// /api/storage-manager.js
class StorageManagerAPI {
  constructor() {
    this.storage = new StorageManager();
  }

  // ä¿å­˜å†å²è®°å½•
  async saveHistory(record) {
    try {
      const result = await this.storage.saveHistory(record);
      
      return {
        success: true,
        data: result
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // è·å–å†å²è®°å½•
  async getHistory(params = {}) {
    try {
      const { page = 1, pageSize = 20, type = null } = params;
      const result = await this.storage.getHistory(page, pageSize, type);
      
      return {
        success: true,
        data: result
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // åˆ é™¤å†å²è®°å½•
  async deleteHistory(id) {
    try {
      await this.storage.deleteHistory(id);
      
      return {
        success: true
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // ä¿å­˜è®¾ç½®
  async saveSettings(key, value) {
    try {
      await this.storage.saveSettings(key, value);
      
      return {
        success: true
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // è·å–è®¾ç½®
  async getSettings(key) {
    try {
      const result = await this.storage.getSettings(key);
      
      return {
        success: true,
        data: result
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
}
```

---

## æ•°æ®åº“è®¾è®¡

### IndexedDB æ•°æ®ç»“æ„

#### 1. å†å²è®°å½•è¡¨ (history)

```javascript
{
  "id": "1630000000000",              // ä¸»é”®ï¼Œæ—¶é—´æˆ³
  "type": "traditional",              // ç±»å‹ï¼štraditional | link
  "timestamp": "2023-08-24T10:00:00Z", // å¤„ç†æ—¶é—´
  "originalPath": "/tmp/original.jpg", // åŸå›¾è·¯å¾„
  "resultPath": "/tmp/result.jpg",     // ç»“æœè·¯å¾„
  "imageSize": 1920000,               // å›¾ç‰‡å¤§å°
  "processingTime": 2500,             // å¤„ç†æ—¶é—´(ms)
  "quality": 4.5,                     // è´¨é‡è¯„åˆ†
  "platform": "å°çº¢ä¹¦",               // å¹³å°ï¼ˆé“¾æ¥æ¨¡å¼ï¼‰
  "originalUrl": "https://...",        // åŸå§‹é“¾æ¥ï¼ˆé“¾æ¥æ¨¡å¼ï¼‰
  "images": [                         // å›¾ç‰‡åˆ—è¡¨ï¼ˆé“¾æ¥æ¨¡å¼ï¼‰
    {
      "url": "https://...",
      "resultPath": "/tmp/result1.jpg",
      "processed": true,
      "fileSize": 1024000
    }
  ]
}
```

#### 2. è®¾ç½®è¡¨ (settings)

```javascript
{
  "key": "imageQuality",               // è®¾ç½®é”®
  "value": "high",                    // è®¾ç½®å€¼
  "updatedAt": "2023-08-24T10:00:00Z" // æ›´æ–°æ—¶é—´
}
```

#### 3. ç¼“å­˜è¡¨ (cache)

```javascript
{
  "url": "https://example.com/image.jpg", // ç¼“å­˜é”®
  "data": "base64_encoded_image_data",   // ç¼“å­˜æ•°æ®
  "timestamp": "2023-08-24T10:00:00Z",   // ç¼“å­˜æ—¶é—´
  "expiresAt": "2023-08-31T10:00:00Z"     // è¿‡æœŸæ—¶é—´
}
```

### æ•°æ®æ“ä½œæ¥å£

```javascript
// /database/operations.js
class DatabaseOperations {
  constructor() {
    this.db = null;
    this.initDB();
  }

  async initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('WatermarkRemoverDB', 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // åˆ›å»ºå†å²è®°å½•è¡¨
        if (!db.objectStoreNames.contains('history')) {
          const historyStore = db.createObjectStore('history', {
            keyPath: 'id',
            autoIncrement: true
          });
          historyStore.createIndex('timestamp', 'timestamp', { unique: false });
          historyStore.createIndex('type', 'type', { unique: false });
        }
        
        // åˆ›å»ºè®¾ç½®è¡¨
        if (!db.objectStoreNames.contains('settings')) {
          db.createObjectStore('settings', { keyPath: 'key' });
        }
        
        // åˆ›å»ºç¼“å­˜è¡¨
        if (!db.objectStoreNames.contains('cache')) {
          const cacheStore = db.createObjectStore('cache', { keyPath: 'url' });
          cacheStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }

  // æŸ¥è¯¢å†å²è®°å½•
  async queryHistory(params = {}) {
    const { page = 1, pageSize = 20, type = null, startDate, endDate } = params;
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['history'], 'readonly');
      const store = transaction.objectStore('history');
      
      let request;
      if (type) {
        const index = store.index('type');
        request = index.openCursor(IDBKeyRange.only(type));
      } else {
        request = store.openCursor();
      }
      
      const records = [];
      let count = 0;
      const start = (page - 1) * pageSize;
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        
        if (cursor) {
          const record = cursor.value;
          
          // æ—¥æœŸè¿‡æ»¤
          if (startDate && new Date(record.timestamp) < new Date(startDate)) {
            cursor.continue();
            return;
          }
          
          if (endDate && new Date(record.timestamp) > new Date(endDate)) {
            cursor.continue();
            return;
          }
          
          if (count >= start && count < start + pageSize) {
            records.push(record);
          }
          count++;
          cursor.continue();
        } else {
          resolve({
            records: records,
            total: count,
            page: page,
            pageSize: pageSize
          });
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  // ç»Ÿè®¡æŸ¥è¯¢
  async getStatistics() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['history'], 'readonly');
      const store = transaction.objectStore('history');
      
      const request = store.getAll();
      
      request.onsuccess = () => {
        const records = request.result;
        
        const statistics = {
          total: records.length,
          traditional: records.filter(r => r.type === 'traditional').length,
          link: records.filter(r => r.type === 'link').length,
          success: records.filter(r => r.quality > 3).length,
          platforms: {},
          monthlyData: {}
        };
        
        // å¹³å°ç»Ÿè®¡
        records.forEach(record => {
          if (record.platform) {
            statistics.platforms[record.platform] = (statistics.platforms[record.platform] || 0) + 1;
          }
        });
        
        // æœˆåº¦ç»Ÿè®¡
        records.forEach(record => {
          const month = new Date(record.timestamp).toISOString().substring(0, 7);
          statistics.monthlyData[month] = (statistics.monthlyData[month] || 0) + 1;
        });
        
        resolve(statistics);
      };
      
      request.onerror = () => reject(request.error);
    });
  }
}
```

---

## éƒ¨ç½²æ–¹æ¡ˆ

### å¾®ä¿¡å°ç¨‹åºéƒ¨ç½²

#### 1. å¼€å‘ç¯å¢ƒé…ç½®

```json
// project.config.json
{
  "description": "é¡¹ç›®é…ç½®æ–‡ä»¶",
  "packOptions": {
    "ignore": [],
    "include": []
  },
  "miniprogramRoot": "miniprogram/",
  "compileType": "miniprogram",
  "projectname": "å»æ°´å°å°ç¨‹åº",
  "setting": {
    "useCompilerPlugins": [
      "sass"
    ],
    "babelSetting": {
      "ignore": [],
      "disablePlugins": [],
      "outputPath": ""
    },
    "es6": true,
    "enhance": true,
    "postcss": true,
    "condition": false,
    "packNpmManually": false,
    "packNpmRelationList": [],
    "minifyWXSS": true,
    "minifyWXML": true,
    "showES6CompileOption": false,
    "useMultiFrameRuntime": true,
    "useApiHook": true,
    "useApiHostProcess": true
  },
  "simulatorType": "wechat",
  "simulatorPluginLibVersion": {},
  "condition": {},
  "srcMiniprogramRoot": "miniprogram/",
  "appid": "your_appid_here",
  "libVersion": "2.32.3",
  "editorSetting": {
    "tabIndent": "insertSpaces",
    "tabSize": 2
  }
}
```

#### 2. å°ç¨‹åºé…ç½®

```json
// app.json
{
  "pages": [
    "pages/index/index",
    "pages/link-process/index",
    "pages/result/index",
    "pages/history/index",
    "pages/settings/index"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#4A90E2",
    "navigationBarTitleText": "æ™ºèƒ½å»æ°´å°åŠ©æ‰‹",
    "navigationBarTextStyle": "white"
  },
  "tabBar": {
    "color": "#7A7E83",
    "selectedColor": "#4A90E2",
    "backgroundColor": "#ffffff",
    "borderStyle": "black",
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "é¦–é¡µ",
        "iconPath": "images/home.png",
        "selectedIconPath": "images/home-active.png"
      },
      {
        "pagePath": "pages/history/index",
        "text": "å†å²",
        "iconPath": "images/history.png",
        "selectedIconPath": "images/history-active.png"
      },
      {
        "pagePath": "pages/settings/index",
        "text": "è®¾ç½®",
        "iconPath": "images/settings.png",
        "selectedIconPath": "images/settings-active.png"
      }
    ]
  },
  "permission": {
    "scope.writePhotosAlbum": {
      "desc": "éœ€è¦ä¿å­˜å¤„ç†åçš„å›¾ç‰‡åˆ°ç›¸å†Œ"
    },
    "scope.camera": {
      "desc": "éœ€è¦ä½¿ç”¨ç›¸æœºæ‹ç…§"
    }
  },
  "requiredBackgroundModes": ["download"],
  "lazyCodeLoading": "requiredComponents"
}
```

#### 3. æƒé™é…ç½®

```json
// app.json
"permission": {
  "scope.writePhotosAlbum": {
    "desc": "éœ€è¦ä¿å­˜å¤„ç†åçš„å›¾ç‰‡åˆ°ç›¸å†Œ"
  },
  "scope.camera": {
    "desc": "éœ€è¦ä½¿ç”¨ç›¸æœºæ‹ç…§"
  }
}
```

#### 4. å‘å¸ƒæµç¨‹

```bash
# 1. æœ¬åœ°å¼€å‘è°ƒè¯•
npm run dev

# 2. ä»£ç æ£€æŸ¥
npm run lint

# 3. æ„å»ºç”Ÿäº§ç‰ˆæœ¬
npm run build

# 4. ä¸Šä¼ ä»£ç åˆ°å¾®ä¿¡å¼€å‘è€…å·¥å…·
# 5. æäº¤å®¡æ ¸
# 6. å‘å¸ƒä¸Šçº¿
```

### Webç‰ˆæœ¬éƒ¨ç½²ï¼ˆå¯é€‰ï¼‰

#### 1. Viteé…ç½®

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  base: './',
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    rollupOptions: {
      output: {
        manualChunks: {
          'opencv': ['opencv.js'],
          'worker': ['./workers/image-processor.worker.js']
        }
      }
    }
  },
  server: {
    port: 3000,
    open: true
  }
})
```

#### 2. é™æ€éƒ¨ç½²

```bash
# æ„å»ºWebç‰ˆæœ¬
npm run build:web

# éƒ¨ç½²åˆ°GitHub Pages
npm run deploy:github

# éƒ¨ç½²åˆ°Netlify
npm run deploy:netlify
```

---

## å¼€å‘è§„èŒƒ

### ä»£ç è§„èŒƒ

#### 1. JavaScriptè§„èŒƒ

```javascript
// ä½¿ç”¨ES6+è¯­æ³•
import ImageProcessor from './image-processor.js';

// ä½¿ç”¨async/awaitå¤„ç†å¼‚æ­¥
class ImageService {
  async processImage(imagePath) {
    try {
      const processor = new ImageProcessor();
      const result = await processor.process(imagePath);
      return result;
    } catch (error) {
      console.error('å¤„ç†å¤±è´¥:', error);
      throw error;
    }
  }
}

// ä½¿ç”¨ç±»å’Œæ¨¡å—åŒ–
export default ImageService;
```

#### 2. CSSè§„èŒƒ

```css
/* ä½¿ç”¨BEMå‘½åè§„èŒƒ */
.watermark-remover {
  &__header {
    /* å¤´éƒ¨æ ·å¼ */
  }
  
  &__content {
    /* å†…å®¹æ ·å¼ */
  }
  
  &--active {
    /* æ¿€æ´»çŠ¶æ€ */
  }
}

/* ä½¿ç”¨CSSå˜é‡ */
:root {
  --primary-color: #4A90E2;
  --secondary-color: #7B68EE;
  --success-color: #52C41A;
  --warning-color: #FAAD14;
  --error-color: #F5222D;
}
```

#### 3. æ–‡ä»¶å‘½åè§„èŒƒ

```
# é¡µé¢æ–‡ä»¶
pages/index/index.js
pages/index/index.wxml
pages/index/index.wxss
pages/index/index.json

# ç»„ä»¶æ–‡ä»¶
components/image-uploader/image-uploader.js
components/image-uploader/image-uploader.wxml
components/image-uploader/image-uploader.wxss
components/image-uploader/image-uploader.json

# å·¥å…·æ–‡ä»¶
utils/image-processor.js
utils/link-parser.js
utils/storage-manager.js

# æ ·å¼æ–‡ä»¶
styles/common.wxss
styles/variables.wxss
```

### Gitå·¥ä½œæµ

#### 1. åˆ†æ”¯ç­–ç•¥

```bash
# ä¸»åˆ†æ”¯
main (ç”Ÿäº§ç¯å¢ƒ)
develop (å¼€å‘ç¯å¢ƒ)

# åŠŸèƒ½åˆ†æ”¯
feature/image-processing
feature/link-parser
feature/storage-system

# ä¿®å¤åˆ†æ”¯
bugfix/memory-leak
bugfix/cors-issue
```

#### 2. æäº¤è§„èŒƒ

```bash
# æäº¤æ ¼å¼
<type>(<scope>): <description>

# ç±»å‹è¯´æ˜
feat: æ–°åŠŸèƒ½
fix: ä¿®å¤bug
docs: æ–‡æ¡£æ›´æ–°
style: ä»£ç æ ¼å¼
refactor: é‡æ„
test: æµ‹è¯•
chore: æ„å»ºæˆ–å·¥å…·å˜åŠ¨

# ç¤ºä¾‹
feat(image): æ·»åŠ å›¾åƒå¤„ç†åŠŸèƒ½
fix(parser): ä¿®å¤é“¾æ¥è§£æè·¨åŸŸé—®é¢˜
docs(readme): æ›´æ–°é¡¹ç›®æ–‡æ¡£
style(format): ä»£ç æ ¼å¼åŒ–
```

#### 3. ä»£ç æ£€æŸ¥

```javascript
// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true
  },
  extends: [
    'eslint:recommended',
    '@vue/eslint-config-prettier'
  ],
  parserOptions: {
    ecmaVersion: 12,
    sourceType: 'module'
  },
  rules: {
    'no-console': 'warn',
    'no-unused-vars': 'error',
    'prefer-const': 'error',
    'no-var': 'error'
  }
}
```

### æµ‹è¯•è§„èŒƒ

#### 1. å•å…ƒæµ‹è¯•

```javascript
// tests/unit/image-processor.test.js
import ImageProcessor from '../../utils/image-processor.js';

describe('ImageProcessor', () => {
  let processor;

  beforeEach(() => {
    processor = new ImageProcessor();
  });

  test('should detect watermark', async () => {
    const imageData = createMockImageData();
    const maskData = await processor.detectWatermark(imageData);
    
    expect(maskData).toBeDefined();
    expect(maskData.width).toBe(imageData.width);
    expect(maskData.height).toBe(imageData.height);
  });

  test('should inpaint image', async () => {
    const imageData = createMockImageData();
    const maskData = createMockMaskData();
    const resultData = await processor.inpaint(imageData, maskData);
    
    expect(resultData).toBeDefined();
    expect(resultData.width).toBe(imageData.width);
    expect(resultData.height).toBe(imageData.height);
  });
});
```

#### 2. é›†æˆæµ‹è¯•

```javascript
// tests/integration/link-parser.test.js
import LinkParser from '../../utils/link-parser.js';

describe('LinkParser', () => {
  let parser;

  beforeEach(() => {
    parser = new LinkParser();
  });

  test('should parse xiaohongshu link', async () => {
    const url = 'https://www.xiaohongshu.com/explore/123456';
    const result = await parser.parseLink(url);
    
    expect(result.platform).toBe('å°çº¢ä¹¦');
    expect(result.images).toBeDefined();
    expect(result.images.length).toBeGreaterThan(0);
  });

  test('should handle invalid link', async () => {
    const url = 'https://invalid-url.com';
    
    await expect(parser.parseLink(url)).rejects.toThrow();
  });
});
```

---

## æµ‹è¯•æ–¹æ¡ˆ

### å•å…ƒæµ‹è¯•

#### 1. å›¾åƒå¤„ç†æµ‹è¯•

```javascript
// tests/unit/image-processing.test.js
import { expect, test } from '@jest/globals';
import ImageProcessor from '../../utils/image-processor.js';

describe('Image Processing', () => {
  let processor;

  beforeEach(() => {
    processor = new ImageProcessor();
  });

  test('should create canvas with correct dimensions', () => {
    processor.initCanvas(800, 600);
    
    expect(processor.canvas.width).toBe(800);
    expect(processor.canvas.height).toBe(600);
    expect(processor.ctx).toBeDefined();
  });

  test('should detect watermark in bright areas', async () => {
    // åˆ›å»ºæµ‹è¯•å›¾ç‰‡æ•°æ®ï¼ˆåŒ…å«äº®è‰²æ°´å°ï¼‰
    const imageData = createTestImageDataWithWatermark();
    const maskData = await processor.detectWatermark(imageData);
    
    // éªŒè¯æ°´å°æ£€æµ‹åŒºåŸŸ
    const watermarkArea = getWatermarkArea(maskData);
    expect(watermarkArea).toBeDefined();
    expect(watermarkArea.pixelCount).toBeGreaterThan(0);
  });

  test('should inpaint image using neighboring pixels', async () => {
    const imageData = createTestImageData();
    const maskData = createTestMaskData();
    const resultData = await processor.inpaint(imageData, maskData);
    
    // éªŒè¯ä¿®å¤ç»“æœ
    expect(resultData).toBeDefined();
    expect(resultData.data.length).toBe(imageData.data.length);
    
    // éªŒè¯æ°´å°åŒºåŸŸè¢«ä¿®å¤
    const inpaintedArea = getInpaintedArea(resultData, imageData);
    expect(inpaintedArea.difference).toBeLessThan(50); // å·®å¼‚é˜ˆå€¼
  });

  test('should handle edge cases', async () => {
    // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
    const smallImageData = createSmallImageData();
    const maskData = createTestMaskData();
    
    const resultData = await processor.inpaint(smallImageData, maskData);
    expect(resultData).toBeDefined();
  });
});

// è¾…åŠ©å‡½æ•°
function createTestImageDataWithWatermark() {
  // åˆ›å»ºåŒ…å«äº®è‰²æ°´å°çš„æµ‹è¯•æ•°æ®
  const width = 100;
  const height = 100;
  const data = new Uint8ClampedArray(width * height * 4);
  
  // å¡«å……åŸºç¡€é¢œè‰²
  for (let i = 0; i < data.length; i += 4) {
    data[i] = 100;     // R
    data[i + 1] = 100; // G
    data[i + 2] = 100; // B
    data[i + 3] = 255; // A
  }
  
  // æ·»åŠ äº®è‰²æ°´å°åŒºåŸŸ
  for (let y = 40; y < 60; y++) {
    for (let x = 40; x < 60; x++) {
      const idx = (y * width + x) * 4;
      data[idx] = 255;     // R
      data[idx + 1] = 255; // G
      data[idx + 2] = 255; // B
      data[idx + 3] = 255; // A
    }
  }
  
  return new ImageData(data, width, height);
}
```

#### 2. é“¾æ¥è§£ææµ‹è¯•

```javascript
// tests/unit/link-parser.test.js
import { expect, test } from '@jest/globals';
import LinkParser from '../../utils/link-parser.js';

describe('Link Parser', () => {
  let parser;

  beforeEach(() => {
    parser = new LinkParser();
  });

  test('should detect xiaohongshu platform', () => {
    const url = 'https://www.xiaohongshu.com/explore/123456';
    const platform = parser.detectPlatform(url);
    
    expect(platform).toBeDefined();
    expect(platform.name).toBe('å°çº¢ä¹¦');
  });

  test('should detect douyin platform', () => {
    const url = 'https://www.douyin.com/video/123456';
    const platform = parser.detectPlatform(url);
    
    expect(platform).toBeDefined();
    expect(platform.name).toBe('æŠ–éŸ³');
  });

  test('should detect weibo platform', () => {
    const url = 'https://weibo.com/123456/status/7890';
    const platform = parser.detectPlatform(url);
    
    expect(platform).toBeDefined();
    expect(platform.name).toBe('å¾®åš');
  });

  test('should return null for unsupported platform', () => {
    const url = 'https://unsupported-platform.com/content';
    const platform = parser.detectPlatform(url);
    
    expect(platform).toBeNull();
  });

  test('should validate image URLs', () => {
    expect(parser.isImageUrl('https://example.com/image.jpg')).toBe(true);
    expect(parser.isImageUrl('https://example.com/image.png')).toBe(true);
    expect(parser.isImageUrl('https://example.com/image.gif')).toBe(true);
    expect(parser.isImageUrl('https://example.com/page.html')).toBe(false);
    expect(parser.isImageUrl('https://example.com/video.mp4')).toBe(false);
  });

  test('should resolve relative URLs', () => {
    const baseUrl = 'https://example.com/page/';
    const relativeUrl = 'image.jpg';
    const resolvedUrl = parser.resolveUrl(relativeUrl, baseUrl);
    
    expect(resolvedUrl).toBe('https://example.com/page/image.jpg');
  });
});
```

#### 3. å­˜å‚¨ç®¡ç†æµ‹è¯•

```javascript
// tests/unit/storage-manager.test.js
import { expect, test } from '@jest/globals';
import StorageManager from '../../utils/storage-manager.js';

describe('Storage Manager', () => {
  let storageManager;

  beforeEach(async () => {
    storageManager = new StorageManager();
    await storageManager.initDB();
  });

  afterEach(async () => {
    await storageManager.clearAllData();
  });

  test('should save and retrieve settings', async () => {
    const key = 'test_setting';
    const value = 'test_value';
    
    await storageManager.saveSettings(key, value);
    const retrievedValue = await storageManager.getSettings(key);
    
    expect(retrievedValue).toBe(value);
  });

  test('should save and retrieve history', async () => {
    const historyRecord = {
      type: 'traditional',
      originalPath: '/test/original.jpg',
      resultPath: '/test/result.jpg',
      processingTime: 1000
    };
    
    const savedRecord = await storageManager.saveHistory(historyRecord);
    expect(savedRecord.id).toBeDefined();
    expect(savedRecord.type).toBe('traditional');
    
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(1);
    expect(history.records[0].id).toBe(savedRecord.id);
  });

  test('should delete history record', async () => {
    const historyRecord = {
      type: 'traditional',
      originalPath: '/test/original.jpg',
      resultPath: '/test/result.jpg'
    };
    
    const savedRecord = await storageManager.saveHistory(historyRecord);
    await storageManager.deleteHistory(savedRecord.id);
    
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(0);
  });

  test('should cache and retrieve image data', async () => {
    const url = 'https://example.com/test.jpg';
    const imageData = new Uint8Array([1, 2, 3, 4, 5]);
    
    await storageManager.cacheImage(url, imageData);
    const cachedData = await storageManager.getCachedImage(url);
    
    expect(cachedData).toEqual(imageData);
  });
});
```

### é›†æˆæµ‹è¯•

#### 1. å®Œæ•´æµç¨‹æµ‹è¯•

```javascript
// tests/integration/full-workflow.test.js
import { expect, test } from '@jest/globals';
import ImageProcessor from '../../utils/image-processor.js';
import LinkParser from '../../utils/link-parser.js';
import StorageManager from '../../utils/storage-manager.js';

describe('Full Workflow Integration', () => {
  let imageProcessor;
  let linkParser;
  let storageManager;

  beforeEach(async () => {
    imageProcessor = new ImageProcessor();
    linkParser = new LinkParser();
    storageManager = new StorageManager();
    await storageManager.initDB();
  });

  test('should complete traditional image processing workflow', async () => {
    // 1. æ¨¡æ‹Ÿå›¾ç‰‡ä¸Šä¼ 
    const mockImagePath = '/mock/image.jpg';
    const mockImageData = createMockImageData();
    
    // 2. å¤„ç†å›¾ç‰‡
    const maskData = await imageProcessor.detectWatermark(mockImageData);
    const resultData = await imageProcessor.inpaint(mockImageData, maskData);
    
    // 3. ä¿å­˜å†å²è®°å½•
    const historyRecord = {
      type: 'traditional',
      originalPath: mockImagePath,
      resultPath: '/mock/result.jpg',
      processingTime: Date.now()
    };
    
    const savedRecord = await storageManager.saveHistory(historyRecord);
    
    // 4. éªŒè¯ç»“æœ
    expect(savedRecord).toBeDefined();
    expect(savedRecord.type).toBe('traditional');
    expect(savedRecord.processingTime).toBeDefined();
    
    // 5. éªŒè¯å†å²è®°å½•
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(1);
    expect(history.records[0].id).toBe(savedRecord.id);
  });

  test('should complete link processing workflow', async () => {
    // 1. æ¨¡æ‹Ÿé“¾æ¥è§£æ
    const mockUrl = 'https://www.xiaohongshu.com/explore/123456';
    const mockContent = createMockXiaohongshuContent();
    
    // 2. è§£æé“¾æ¥ï¼ˆæ¨¡æ‹Ÿï¼‰
    jest.spyOn(linkParser, 'fetchWithProxy').mockResolvedValue(mockContent);
    const parseResult = await linkParser.parseLink(mockUrl);
    
    // 3. éªŒè¯è§£æç»“æœ
    expect(parseResult.platform).toBe('å°çº¢ä¹¦');
    expect(parseResult.images).toBeDefined();
    expect(parseResult.images.length).toBeGreaterThan(0);
    
    // 4. ä¿å­˜å†å²è®°å½•
    const historyRecord = {
      type: 'link',
      originalUrl: mockUrl,
      platform: parseResult.platform,
      images: parseResult.images,
      processingTime: Date.now()
    };
    
    const savedRecord = await storageManager.saveHistory(historyRecord);
    
    // 5. éªŒè¯å†å²è®°å½•
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(1);
    expect(history.records[0].platform).toBe('å°çº¢ä¹¦');
  });

  test('should handle errors gracefully', async () => {
    // æµ‹è¯•æ— æ•ˆé“¾æ¥å¤„ç†
    const invalidUrl = 'https://invalid-url.com';
    
    await expect(linkParser.parseLink(invalidUrl)).rejects.toThrow();
    
    // éªŒè¯é”™è¯¯æƒ…å†µä¸‹ä¸ä¼šä¿å­˜é”™è¯¯æ•°æ®
    const history = await storageManager.getHistory();
    expect(history.records).toHaveLength(0);
  });
});
```

### æ€§èƒ½æµ‹è¯•

#### 1. å›¾åƒå¤„ç†æ€§èƒ½æµ‹è¯•

```javascript
// tests/performance/image-processing.test.js
import { expect, test } from '@jest/globals';
import ImageProcessor from '../../utils/image-processor.js';
import PerformanceOptimizer from '../../utils/performance-optimizer.js';

describe('Image Processing Performance', () => {
  let imageProcessor;
  let performanceOptimizer;

  beforeEach(() => {
    imageProcessor = new ImageProcessor();
    performanceOptimizer = new PerformanceOptimizer();
  });

  test('should process small image quickly', async () => {
    const smallImageData = createTestImageData(100, 100);
    const maskData = createTestMaskData(100, 100);
    
    const startTime = performance.now();
    const resultData = await imageProcessor.inpaint(smallImageData, maskData);
    const endTime = performance.now();
    
    const processingTime = endTime - startTime;
    
    expect(resultData).toBeDefined();
    expect(processingTime).toBeLessThan(1000); // å°äº1ç§’
  });

  test('should handle large image without memory issues', async () => {
    const largeImageData = createTestImageData(2000, 2000);
    const maskData = createTestMaskData(2000, 2000);
    
    const startTime = performance.now();
    const resultData = await performanceOptimizer.processLargeImage(largeImageData, 512);
    const endTime = performance.now();
    
    const processingTime = endTime - startTime;
    
    expect(resultData).toBeDefined();
    expect(processingTime).toBeLessThan(5000); // å°äº5ç§’
  });

  test('should compress image efficiently', async () => {
    const largeImageData = createTestImageData(4000, 3000);
    
    const startTime = performance.now();
    const compressedImage = await performanceOptimizer.compressImage(largeImageData, 0.8);
    const endTime = performance.now();
    
    const compressionTime = endTime - startTime;
    
    expect(compressedImage).toBeDefined();
    expect(compressedImage.width).toBeLessThanOrEqual(1920);
    expect(compressedImage.height).toBeLessThanOrEqual(1920);
    expect(compressionTime).toBeLessThan(2000); // å°äº2ç§’
  });
});
```

### æµ‹è¯•è¦†ç›–ç‡

```javascript
// jest.config.js
module.exports = {
  preset: 'jest-preset-wechat',
  testEnvironment: 'jsdom',
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/tests/'
  ],
  collectCoverageFrom: [
    'miniprogram/**/*.js',
    'utils/**/*.js',
    '!**/node_modules/**',
    '!**/tests/**'
  ],
  testMatch: [
    '**/tests/**/*.test.js'
  ],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js']
};
```

---

## è¿ç»´ç›‘æ§

### æ€§èƒ½ç›‘æ§

#### 1. å‰ç«¯æ€§èƒ½ç›‘æ§

```javascript
// utils/monitoring.js
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      imageProcessing: [],
      linkParsing: [],
      storageOperations: [],
      memoryUsage: []
    };
    this.initMonitoring();
  }

  initMonitoring() {
    // ç›‘æ§å›¾ç‰‡å¤„ç†æ€§èƒ½
    this.monitorImageProcessing();
    
    // ç›‘æ§å†…å­˜ä½¿ç”¨
    this.monitorMemoryUsage();
    
    // ç›‘æ§é¡µé¢æ€§èƒ½
    this.monitorPagePerformance();
  }

  monitorImageProcessing() {
    const originalProcess = ImageProcessor.prototype.inpaint;
    
    ImageProcessor.prototype.inpaint = async function(imageData, maskData) {
      const startTime = performance.now();
      const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
      
      try {
        const result = await originalProcess.call(this, imageData, maskData);
        
        const endTime = performance.now();
        const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
        
        // è®°å½•æ€§èƒ½æŒ‡æ ‡
        this.recordMetric('imageProcessing', {
          duration: endTime - startTime,
          memoryUsed: endMemory - startMemory,
          imageSize: imageData.width * imageData.height,
          timestamp: Date.now()
        });
        
        return result;
      } catch (error) {
        this.recordError('imageProcessing', error);
        throw error;
      }
    };
  }

  monitorMemoryUsage() {
    setInterval(() => {
      if (performance.memory) {
        this.recordMetric('memoryUsage', {
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize,
          limit: performance.memory.jsHeapSizeLimit,
          timestamp: Date.now()
        });
      }
    }, 30000); // æ¯30ç§’è®°å½•ä¸€æ¬¡
  }

  monitorPagePerformance() {
    if (typeof wx !== 'undefined') {
      wx.onMemoryWarning((res) => {
        this.recordMetric('memoryWarning', {
          level: res.level,
          timestamp: Date.now()
        });
      });
    }
  }

  recordMetric(type, data) {
    this.metrics[type].push(data);
    
    // ä¿æŒæœ€è¿‘1000æ¡è®°å½•
    if (this.metrics[type].length > 1000) {
      this.metrics[type] = this.metrics[type].slice(-1000);
    }
    
    // æœ¬åœ°å­˜å‚¨å…³é”®æŒ‡æ ‡
    this.persistMetrics();
  }

  recordError(type, error) {
    const errorData = {
      message: error.message,
      stack: error.stack,
      timestamp: Date.now()
    };
    
    // å­˜å‚¨é”™è¯¯ä¿¡æ¯
    const errors = this.getStoredErrors();
    errors.push(errorData);
    
    // ä¿æŒæœ€è¿‘100æ¡é”™è¯¯è®°å½•
    if (errors.length > 100) {
      errors.shift();
    }
    
    wx.setStorageSync('error_logs', errors);
  }

  persistMetrics() {
    try {
      const summary = this.getMetricsSummary();
      wx.setStorageSync('performance_metrics', summary);
    } catch (error) {
      console.error('Failed to persist metrics:', error);
    }
  }

  getMetricsSummary() {
    const summary = {};
    
    for (const [type, metrics] of Object.entries(this.metrics)) {
      if (metrics.length > 0) {
        summary[type] = {
          count: metrics.length,
          avgDuration: this.calculateAverage(metrics.map(m => m.duration)),
          maxDuration: Math.max(...metrics.map(m => m.duration)),
          minDuration: Math.min(...metrics.map(m => m.duration)),
          lastUpdated: Date.now()
        };
      }
    }
    
    return summary;
  }

  calculateAverage(numbers) {
    if (numbers.length === 0) return 0;
    return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  }

  getStoredErrors() {
    try {
      return wx.getStorageSync('error_logs') || [];
    } catch (error) {
      return [];
    }
  }

  getPerformanceReport() {
    return {
      metrics: this.getMetricsSummary(),
      errors: this.getStoredErrors(),
      deviceInfo: this.getDeviceInfo(),
      timestamp: Date.now()
    };
  }

  getDeviceInfo() {
    if (typeof wx !== 'undefined') {
      return {
        system: wx.getSystemInfoSync(),
        platform: 'miniprogram'
      };
    } else {
      return {
        userAgent: navigator.userAgent,
        platform: 'web'
      };
    }
  }

  // æ¸…ç†æ—§çš„ç›‘æ§æ•°æ®
  cleanup() {
    const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    
    for (const [type, metrics] of Object.entries(this.metrics)) {
      this.metrics[type] = metrics.filter(m => m.timestamp > oneWeekAgo);
    }
    
    this.persistMetrics();
  }
}

export default PerformanceMonitor;
```

#### 2. é”™è¯¯ç›‘æ§

```javascript
// utils/error-handler.js
class ErrorHandler {
  constructor() {
    this.errorQueue = [];
    this.maxErrors = 50;
    this.initErrorHandling();
  }

  initErrorHandling() {
    // å…¨å±€é”™è¯¯å¤„ç†
    if (typeof wx !== 'undefined') {
      wx.onError((error) => {
        this.handleError(error, 'wx.onError');
      });
      
      wx.onUnhandledRejection((event) => {
        this.handleError(event.reason, 'unhandledRejection');
      });
    } else {
      window.addEventListener('error', (event) => {
        this.handleError(event.error, 'window.error');
      });
      
      window.addEventListener('unhandledrejection', (event) => {
        this.handleError(event.reason, 'unhandledRejection');
      });
    }
  }

  handleError(error, source = 'unknown') {
    const errorData = {
      message: error.message || String(error),
      stack: error.stack || '',
      source: source,
      timestamp: Date.now(),
      userAgent: this.getUserAgent(),
      url: this.getCurrentUrl()
    };

    this.errorQueue.push(errorData);

    // ä¿æŒé”™è¯¯é˜Ÿåˆ—å¤§å°
    if (this.errorQueue.length > this.maxErrors) {
      this.errorQueue.shift();
    }

    // æŒä¹…åŒ–é”™è¯¯æ•°æ®
    this.persistErrors();

    // ä¸ŠæŠ¥é”™è¯¯ï¼ˆå¯é€‰ï¼‰
    this.reportError(errorData);

    // ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
    this.showUserFriendlyError(error);
  }

  getUserAgent() {
    if (typeof wx !== 'undefined') {
      const systemInfo = wx.getSystemInfoSync();
      return `${systemInfo.platform} ${systemInfo.system} ${systemInfo.version}`;
    } else {
      return navigator.userAgent;
    }
  }

  getCurrentUrl() {
    if (typeof wx !== 'undefined') {
      const pages = getCurrentPages();
      if (pages.length > 0) {
        return pages[pages.length - 1].route;
      }
      return 'unknown';
    } else {
      return window.location.href;
    }
  }

  persistErrors() {
    try {
      wx.setStorageSync('error_logs', this.errorQueue);
    } catch (error) {
      console.error('Failed to persist errors:', error);
    }
  }

  reportError(errorData) {
    // è¿™é‡Œå¯ä»¥å®ç°é”™è¯¯ä¸ŠæŠ¥é€»è¾‘
    // ä¾‹å¦‚å‘é€åˆ°ç›‘æ§æœåŠ¡æˆ–åˆ†æå¹³å°
    console.log('Error reported:', errorData);
  }

  showUserFriendlyError(error) {
    let userMessage = 'æ“ä½œå¤±è´¥ï¼Œè¯·é‡è¯•';

    // æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„æ¶ˆæ¯
    if (error.message.includes('network')) {
      userMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®';
    } else if (error.message.includes('memory')) {
      userMessage = 'å†…å­˜ä¸è¶³ï¼Œè¯·å…³é—­å…¶ä»–åº”ç”¨åé‡è¯•';
    } else if (error.message.includes('permission')) {
      userMessage = 'æ²¡æœ‰ç›¸åº”æƒé™ï¼Œè¯·åœ¨è®¾ç½®ä¸­å¼€å¯';
    }

    if (typeof wx !== 'undefined') {
      wx.showToast({
        title: userMessage,
        icon: 'none',
        duration: 3000
      });
    } else {
      alert(userMessage);
    }
  }

  getErrorReport() {
    return {
      errors: this.errorQueue,
      errorCount: this.errorQueue.length,
      lastError: this.errorQueue[this.errorQueue.length - 1],
      timestamp: Date.now()
    };
  }

  clearErrors() {
    this.errorQueue = [];
    this.persistErrors();
  }
}

export default ErrorHandler;
```

### æ—¥å¿—ç®¡ç†

#### 1. æœ¬åœ°æ—¥å¿—ç³»ç»Ÿ

```javascript
// utils/logger.js
class Logger {
  constructor() {
    this.logs = [];
    this.maxLogs = 1000;
    this.levels = {
      DEBUG: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3
    };
    this.currentLevel = this.levels.INFO;
    this.initLogger();
  }

  initLogger() {
    // ä»å­˜å‚¨ä¸­åŠ è½½æ—¥å¿—
    this.loadLogs();
    
    // è®¾ç½®æ—¥å¿—æ¸…ç†å®šæ—¶å™¨
    setInterval(() => this.cleanupLogs(), 24 * 60 * 60 * 1000); // æ¯å¤©æ¸…ç†ä¸€æ¬¡
  }

  loadLogs() {
    try {
      const storedLogs = wx.getStorageSync('app_logs');
      if (storedLogs) {
        this.logs = storedLogs;
      }
    } catch (error) {
      console.error('Failed to load logs:', error);
    }
  }

  saveLogs() {
    try {
      // åªä¿å­˜æœ€è¿‘çš„æ—¥å¿—
      const recentLogs = this.logs.slice(-this.maxLogs);
      wx.setStorageSync('app_logs', recentLogs);
    } catch (error) {
      console.error('Failed to save logs:', error);
    }
  }

  log(level, message, data = {}) {
    const logEntry = {
      level: level,
      message: message,
      data: data,
      timestamp: Date.now(),
      sessionId: this.getSessionId(),
      userId: this.getUserId()
    };

    this.logs.push(logEntry);

    // æ§åˆ¶å°è¾“å‡º
    if (typeof wx !== 'undefined') {
      console.log(`[${level}] ${message}`, data);
    } else {
      console.log(`[${level}] ${message}`, data);
    }

    // ä¿å­˜æ—¥å¿—
    this.saveLogs();

    // å¦‚æœæ˜¯é”™è¯¯çº§åˆ«ï¼ŒåŒæ—¶è®°å½•åˆ°é”™è¯¯å¤„ç†å™¨
    if (level === 'ERROR') {
      this.reportError(logEntry);
    }
  }

  debug(message, data = {}) {
    if (this.currentLevel <= this.levels.DEBUG) {
      this.log('DEBUG', message, data);
    }
  }

  info(message, data = {}) {
    if (this.currentLevel <= this.levels.INFO) {
      this.log('INFO', message, data);
    }
  }

  warn(message, data = {}) {
    if (this.currentLevel <= this.levels.WARN) {
      this.log('WARN', message, data);
    }
  }

  error(message, data = {}) {
    if (this.currentLevel <= this.levels.ERROR) {
      this.log('ERROR', message, data);
    }
  }

  getSessionId() {
    let sessionId = wx.getStorageSync('session_id');
    if (!sessionId) {
      sessionId = Date.now().toString();
      wx.setStorageSync('session_id', sessionId);
    }
    return sessionId;
  }

  getUserId() {
    // å¦‚æœæœ‰ç”¨æˆ·ç³»ç»Ÿï¼Œè¿”å›ç”¨æˆ·ID
    return wx.getStorageSync('user_id') || 'anonymous';
  }

  reportError(logEntry) {
    // æŠ¥å‘Šé”™è¯¯åˆ°ç›‘æ§ç³»ç»Ÿ
    if (typeof ErrorHandler !== 'undefined') {
      const errorHandler = new ErrorHandler();
      errorHandler.handleError({
        message: logEntry.message,
        stack: JSON.stringify(logEntry.data)
      }, 'logger');
    }
  }

  getLogs(filters = {}) {
    let filteredLogs = [...this.logs];

    // æŒ‰çº§åˆ«è¿‡æ»¤
    if (filters.level) {
      filteredLogs = filteredLogs.filter(log => log.level === filters.level);
    }

    // æŒ‰æ—¶é—´èŒƒå›´è¿‡æ»¤
    if (filters.startTime) {
      filteredLogs = filteredLogs.filter(log => log.timestamp >= filters.startTime);
    }

    if (filters.endTime) {
      filteredLogs = filteredLogs.filter(log => log.timestamp <= filters.endTime);
    }

    // æŒ‰å…³é”®è¯è¿‡æ»¤
    if (filters.keyword) {
      filteredLogs = filteredLogs.filter(log => 
        log.message.includes(filters.keyword) ||
        JSON.stringify(log.data).includes(filters.keyword)
      );
    }

    return filteredLogs;
  }

  getLogStats() {
    const stats = {
      total: this.logs.length,
      byLevel: {},
      byDay: {},
      recentErrors: []
    };

    // æŒ‰çº§åˆ«ç»Ÿè®¡
    for (const [level, count] of Object.entries(this.levels)) {
      stats.byLevel[level] = this.logs.filter(log => log.level === level).length;
    }

    // æŒ‰å¤©ç»Ÿè®¡
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    for (let i = 0; i < 7; i++) {
      const day = new Date(today);
      day.setDate(day.getDate() - i);
      const dayStart = day.getTime();
      const dayEnd = dayStart + 24 * 60 * 60 * 1000;
      
      stats.byDay[day.toISOString().split('T')[0]] = this.logs.filter(
        log => log.timestamp >= dayStart && log.timestamp < dayEnd
      ).length;
    }

    // æœ€è¿‘çš„é”™è¯¯
    stats.recentErrors = this.logs
      .filter(log => log.level === 'ERROR')
      .slice(-10)
      .reverse();

    return stats;
  }

  cleanupLogs() {
    const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
    this.logs = this.logs.filter(log => log.timestamp > oneWeekAgo);
    this.saveLogs();
  }

  exportLogs() {
    return {
      logs: this.logs,
      stats: this.getLogStats(),
      exportTime: Date.now(),
      version: '1.0'
    };
  }

  clearLogs() {
    this.logs = [];
    this.saveLogs();
  }

  setLevel(level) {
    if (this.levels.hasOwnProperty(level)) {
      this.currentLevel = this.levels[level];
    }
  }
}

export default Logger;
```

---

## å®‰å…¨æ–¹æ¡ˆ

### æ•°æ®å®‰å…¨

#### 1. æœ¬åœ°æ•°æ®åŠ å¯†

```javascript
// utils/crypto.js
class CryptoManager {
  constructor() {
    this.secretKey = this.getOrCreateSecretKey();
  }

  getOrCreateSecretKey() {
    let key = wx.getStorageSync('crypto_secret_key');
    if (!key) {
      // ç”Ÿæˆéšæœºå¯†é’¥
      key = this.generateRandomKey();
      wx.setStorageSync('crypto_secret_key', key);
    }
    return key;
  }

  generateRandomKey() {
    const array = new Uint8Array(32);
    for (let i = 0; i < array.length; i++) {
      array[i] = Math.floor(Math.random() * 256);
    }
    return Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  // ç®€å•çš„XORåŠ å¯†
  encrypt(text) {
    const key = this.secretKey;
    let encrypted = '';
    
    for (let i = 0; i < text.length; i++) {
      const charCode = text.charCodeAt(i);
      const keyChar = key.charCodeAt(i % key.length);
      encrypted += String.fromCharCode(charCode ^ keyChar);
    }
    
    return btoa(encrypted); // Base64ç¼–ç 
  }

  decrypt(encryptedText) {
    const key = this.secretKey;
    const decoded = atob(encryptedText); // Base64è§£ç 
    let decrypted = '';
    
    for (let i = 0; i < decoded.length; i++) {
      const charCode = decoded.charCodeAt(i);
      const keyChar = key.charCodeAt(i % key.length);
      decrypted += String.fromCharCode(charCode ^ keyChar);
    }
    
    return decrypted;
  }

  // åŠ å¯†æ•æ„Ÿæ•°æ®
  encryptSensitiveData(data) {
    const sensitiveFields = ['originalPath', 'resultPath', 'url'];
    const encryptedData = { ...data };
    
    for (const field of sensitiveFields) {
      if (encryptedData[field]) {
        encryptedData[field] = this.encrypt(encryptedData[field]);
      }
    }
    
    return encryptedData;
  }

  // è§£å¯†æ•æ„Ÿæ•°æ®
  decryptSensitiveData(data) {
    const sensitiveFields = ['originalPath', 'resultPath', 'url'];
    const decryptedData = { ...data };
    
    for (const field of sensitiveFields) {
      if (decryptedData[field]) {
        try {
          decryptedData[field] = this.decrypt(decryptedData[field]);
        } catch (error) {
          console.error('Failed to decrypt field:', field, error);
        }
      }
    }
    
    return decryptedData;
  }
}

export default CryptoManager;
```

#### 2. éšç§ä¿æŠ¤

```javascript
// utils/privacy.js
class PrivacyManager {
  constructor() {
    this.cryptoManager = new CryptoManager();
    this.anonymizationLevel = this.getAnonymizationLevel();
  }

  getAnonymizationLevel() {
    return wx.getStorageSync('privacy_anonymization_level') || 'basic';
  }

  // åŒ¿ååŒ–ç”¨æˆ·æ•°æ®
  anonymizeUserData(userData) {
    const anonymizedData = { ...userData };
    
    switch (this.anonymizationLevel) {
      case 'strict':
        // ä¸¥æ ¼æ¨¡å¼ï¼šç§»é™¤æ‰€æœ‰å¯è¯†åˆ«ä¿¡æ¯
        delete anonymizedData.userId;
        delete anonymizedData.sessionId;
        delete anonymizedData.deviceId;
        break;
        
      case 'basic':
      default:
        // åŸºæœ¬æ¨¡å¼ï¼šå“ˆå¸Œå¤„ç†å¯è¯†åˆ«ä¿¡æ¯
        if (anonymizedData.userId) {
          anonymizedData.userId = this.hashData(anonymizedData.userId);
        }
        if (anonymizedData.deviceId) {
          anonymizedData.deviceId = this.hashData(anonymizedData.deviceId);
        }
        break;
    }
    
    return anonymizedData;
  }

  // å“ˆå¸Œæ•°æ®
  hashData(data) {
    // ç®€å•çš„å“ˆå¸Œå‡½æ•°
    let hash = 0;
    const str = String(data);
    
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    
    return Math.abs(hash).toString(16);
  }

  // æ£€æŸ¥æ•°æ®æ˜¯å¦åŒ…å«æ•æ„Ÿä¿¡æ¯
  containsSensitiveInfo(data) {
    const sensitivePatterns = [
      /password/i,
      /token/i,
      /secret/i,
      /key/i,
      /auth/i,
      /credential/i
    ];
    
    const dataString = JSON.stringify(data);
    
    return sensitivePatterns.some(pattern => pattern.test(dataString));
  }

  // æ¸…ç†æ•æ„Ÿæ•°æ®
  sanitizeData(data) {
    if (typeof data !== 'object' || data === null) {
      return data;
    }
    
    const sanitized = Array.isArray(data) ? [] : {};
    
    for (const [key, value] of Object.entries(data)) {
      if (this.isSensitiveField(key)) {
        sanitized[key] = '[REDACTED]';
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeData(value);
      } else {
        sanitized[key] = value;
      }
    }
    
    return sanitized;
  }

  isSensitiveField(fieldName) {
    const sensitiveFields = [
      'password', 'token', 'secret', 'key', 'auth',
      'credential', 'session', 'cookie', 'authorization'
    ];
    
    return sensitiveFields.some(field => 
      fieldName.toLowerCase().includes(field)
    );
  }

  // è·å–éšç§æ”¿ç­–
  getPrivacyPolicy() {
    return {
      version: '1.0',
      lastUpdated: new Date().toISOString(),
      dataCollection: {
        images: {
          collected: true,
          purpose: 'æ°´å°å»é™¤å¤„ç†',
          retention: 'æœ¬åœ°å­˜å‚¨ï¼Œç”¨æˆ·å¯åˆ é™¤',
          sharing: 'ä¸ä¸ç¬¬ä¸‰æ–¹å…±äº«'
        },
        links: {
          collected: true,
          purpose: 'è§£æå›¾ç‰‡é“¾æ¥',
          retention: 'ä¸´æ—¶å­˜å‚¨ï¼Œå¤„ç†å®Œæˆååˆ é™¤',
          sharing: 'ä¸ä¸ç¬¬ä¸‰æ–¹å…±äº«'
        },
        usage: {
          collected: true,
          purpose: 'æ”¹å–„ç”¨æˆ·ä½“éªŒ',
          retention: 'æœ¬åœ°å­˜å‚¨ï¼Œç”¨æˆ·å¯åˆ é™¤',
          sharing: 'åŒ¿ååŒ–ç»Ÿè®¡'
        }
      },
      userRights: {
        access: 'ç”¨æˆ·å¯è®¿é—®è‡ªå·±çš„æ•°æ®',
        rectification: 'ç”¨æˆ·å¯æ›´æ­£é”™è¯¯æ•°æ®',
        deletion: 'ç”¨æˆ·å¯åˆ é™¤è‡ªå·±çš„æ•°æ®',
        portability: 'ç”¨æˆ·å¯å¯¼å‡ºè‡ªå·±çš„æ•°æ®'
      }
    };
  }

  // ç”¨æˆ·åŒæ„ç®¡ç†
  setUserConsent(consentType, agreed) {
    const consents = this.getUserConsents();
    consents[consentType] = {
      agreed: agreed,
      timestamp: Date.now(),
      version: '1.0'
    };
    
    wx.setStorageSync('privacy_consents', consents);
  }

  getUserConsents() {
    return wx.getStorageSync('privacy_consents') || {};
  }

  hasUserConsent(consentType) {
    const consents = this.getUserConsents();
    return consents[consentType]?.agreed || false;
  }

  // æ•°æ®å¯¼å‡º
  exportUserData() {
    const userData = {
      history: this.getStoredHistory(),
      settings: this.getStoredSettings(),
      consents: this.getUserConsents(),
      exportTime: new Date().toISOString()
    };
    
    return this.cryptoManager.encryptSensitiveData(userData);
  }

  // æ•°æ®åˆ é™¤
  deleteUserData() {
    // åˆ é™¤æ‰€æœ‰ç”¨æˆ·æ•°æ®
    wx.removeStorageSync('history');
    wx.removeStorageSync('settings');
    wx.removeStorageSync('privacy_consents');
    wx.removeStorageSync('session_id');
    wx.removeStorageSync('user_id');
    
    // æ¸…ç†ç¼“å­˜
    wx.removeStorageSync('cache');
    
    return true;
  }

  getStoredHistory() {
    try {
      return wx.getStorageSync('history') || [];
    } catch (error) {
      return [];
    }
  }

  getStoredSettings() {
    try {
      return wx.getStorageSync('settings') || {};
    } catch (error) {
      return {};
    }
  }
}

export default PrivacyManager;
```

### æƒé™ç®¡ç†

#### 1. æƒé™è¯·æ±‚ç®¡ç†

```javascript
// utils/permissions.js
class PermissionManager {
  constructor() {
    this.permissions = {
      'scope.writePhotosAlbum': {
        name: 'ç›¸å†Œå†™å…¥æƒé™',
        description: 'éœ€è¦ä¿å­˜å¤„ç†åçš„å›¾ç‰‡åˆ°ç›¸å†Œ',
        required: false
      },
      'scope.camera': {
        name: 'ç›¸æœºæƒé™',
        description: 'éœ€è¦ä½¿ç”¨ç›¸æœºæ‹ç…§',
        required: false
      },
      'scope.record': {
        name: 'å½•éŸ³æƒé™',
        description: 'éœ€è¦å½•åˆ¶éŸ³é¢‘',
        required: false
      },
      'scope.userLocation': {
        name: 'ä½ç½®æƒé™',
        description: 'éœ€è¦è·å–ä½ç½®ä¿¡æ¯',
        required: false
      }
    };
  }

  // è¯·æ±‚æƒé™
  async requestPermission(scope) {
    return new Promise((resolve) => {
      wx.authorize({
        scope: scope,
        success: () => resolve(true),
        fail: () => resolve(false)
      });
    });
  }

  // æ£€æŸ¥æƒé™çŠ¶æ€
  async checkPermission(scope) {
    return new Promise((resolve) => {
      wx.getSetting({
        success: (res) => {
          const hasPermission = res.authSetting[scope];
          resolve(hasPermission);
        },
        fail: () => resolve(false)
      });
    });
  }

  // è·å–æƒé™
  async getPermission(scope) {
    const hasPermission = await this.checkPermission(scope);
    
    if (!hasPermission) {
      const permissionInfo = this.permissions[scope];
      if (permissionInfo) {
        // æ˜¾ç¤ºæƒé™è¯´æ˜
        await this.showPermissionDialog(permissionInfo);
        
        // è¯·æ±‚æƒé™
        const granted = await this.requestPermission(scope);
        
        if (!granted) {
          // æƒé™è¢«æ‹’ç»
          await this.showPermissionDeniedDialog(permissionInfo);
          return false;
        }
      } else {
        return false;
      }
    }
    
    return true;
  }

  // æ˜¾ç¤ºæƒé™è¯´æ˜å¯¹è¯æ¡†
  showPermissionDialog(permissionInfo) {
    return new Promise((resolve) => {
      wx.showModal({
        title: 'éœ€è¦æƒé™',
        content: permissionInfo.description,
        confirmText: 'å»è®¾ç½®',
        cancelText: 'å–æ¶ˆ',
        success: (res) => {
          if (res.confirm) {
            wx.openSetting();
          }
          resolve();
        }
      });
    });
  }

  // æ˜¾ç¤ºæƒé™è¢«æ‹’ç»å¯¹è¯æ¡†
  showPermissionDeniedDialog(permissionInfo) {
    return new Promise((resolve) => {
      wx.showModal({
        title: 'æƒé™è¢«æ‹’ç»',
        content: `æ‚¨æ‹’ç»äº†${permissionInfo.name}ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½æ— æ³•æ­£å¸¸ä½¿ç”¨`,
        showCancel: false,
        confirmText: 'æˆ‘çŸ¥é“äº†',
        success: () => resolve()
      });
    });
  }

  // è¯·æ±‚å›¾ç‰‡ä¿å­˜æƒé™
  async requestSaveImagePermission() {
    return await this.getPermission('scope.writePhotosAlbum');
  }

  // è¯·æ±‚ç›¸æœºæƒé™
  async requestCameraPermission() {
    return await this.getPermission('scope.camera');
  }

  // æ‰¹é‡è¯·æ±‚æƒé™
  async requestMultiplePermissions(scopes) {
    const results = {};
    
    for (const scope of scopes) {
      results[scope] = await this.getPermission(scope);
    }
    
    return results;
  }

  // æ£€æŸ¥æ‰€æœ‰å¿…è¦æƒé™
  async checkEssentialPermissions() {
    const essentialPermissions = [
      'scope.writePhotosAlbum',
      'scope.camera'
    ];
    
    const results = await this.requestMultiplePermissions(essentialPermissions);
    
    const missingPermissions = Object.entries(results)
      .filter(([_, granted]) => !granted)
      .map(([scope, _]) => scope);
    
    if (missingPermissions.length > 0) {
      console.warn('Missing essential permissions:', missingPermissions);
    }
    
    return {
      allGranted: missingPermissions.length === 0,
      granted: Object.entries(results).filter(([_, granted]) => granted).map(([scope, _]) => scope),
      missing: missingPermissions
    };
  }
}

export default PermissionManager;
```

### å®‰å…¨å®¡è®¡

#### 1. å®‰å…¨å®¡è®¡æ—¥å¿—

```javascript
// utils/security-audit.js
class SecurityAudit {
  constructor() {
    this.auditLogs = [];
    this.maxLogs = 500;
    this.initAudit();
  }

  initAudit() {
    this.loadAuditLogs();
    
    // ç›‘å¬æ•æ„Ÿæ“ä½œ
    this.monitorSensitiveOperations();
  }

  loadAuditLogs() {
    try {
      const storedLogs = wx.getStorageSync('security_audit_logs');
      if (storedLogs) {
        this.auditLogs = storedLogs;
      }
    } catch (error) {
      console.error('Failed to load audit logs:', error);
    }
  }

  saveAuditLogs() {
    try {
      // åªä¿å­˜æœ€è¿‘çš„å®¡è®¡æ—¥å¿—
      const recentLogs = this.auditLogs.slice(-this.maxLogs);
      wx.setStorageSync('security_audit_logs', recentLogs);
    } catch (error) {
      console.error('Failed to save audit logs:', error);
    }
  }

  monitorSensitiveOperations() {
    // ç›‘å¬æ–‡ä»¶æ“ä½œ
    this.monitorFileOperations();
    
    // ç›‘å¬æƒé™è¯·æ±‚
    this.monitorPermissionRequests();
    
    // ç›‘å¬æ•°æ®å­˜å‚¨æ“ä½œ
    this.monitorDataOperations();
  }

  monitorFileOperations() {
    const originalSaveImage = wx.saveImageToPhotosAlbum;
    const self = this;
    
    wx.saveImageToPhotosAlbum = function(options) {
      self.logAudit({
        action: 'SAVE_IMAGE',
        filePath: options.filePath,
        timestamp: Date.now()
      });
      
      return originalSaveImage.call(this, options);
    };
  }

  monitorPermissionRequests() {
    const originalAuthorize = wx.authorize;
    const self = this;
    
    wx.authorize = function(options) {
      self.logAudit({
        action: 'REQUEST_PERMISSION',
        scope: options.scope,
        timestamp: Date.now()
      });
      
      return originalAuthorize.call(this, options);
    };
  }

  monitorDataOperations() {
    // ç›‘æ§æ•°æ®å­˜å‚¨æ“ä½œ
    const originalSetStorage = wx.setStorageSync;
    const self = this;
    
    wx.setStorageSync = function(key, data) {
      if (self.isSensitiveKey(key)) {
        self.logAudit({
          action: 'STORE_SENSITIVE_DATA',
          key: key,
          dataSize: JSON.stringify(data).length,
          timestamp: Date.now()
        });
      }
      
      return originalSetStorage.call(this, key, data);
    };
  }

  isSensitiveKey(key) {
    const sensitiveKeys = [
      'user', 'auth', 'token', 'password',
      'secret', 'key', 'credential'
    ];
    
    return sensitiveKeys.some(sensitiveKey => 
      key.toLowerCase().includes(sensitiveKey)
    );
  }

  logAudit(auditEvent) {
    const auditLog = {
      id: this.generateAuditId(),
      sessionId: this.getSessionId(),
      userId: this.getUserId(),
      ...auditEvent,
      deviceInfo: this.getDeviceInfo()
    };

    this.auditLogs.push(auditLog);
    this.saveAuditLogs();
  }

  generateAuditId() {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
  }

  getSessionId() {
    return wx.getStorageSync('session_id') || 'unknown';
  }

  getUserId() {
    return wx.getStorageSync('user_id') || 'anonymous';
  }

  getDeviceInfo() {
    try {
      return wx.getSystemInfoSync();
    } catch (error) {
      return {};
    }
  }

  // è·å–å®¡è®¡æŠ¥å‘Š
  getAuditReport(filters = {}) {
    let filteredLogs = [...this.auditLogs];

    // æŒ‰æ—¶é—´è¿‡æ»¤
    if (filters.startTime) {
      filteredLogs = filteredLogs.filter(log => log.timestamp >= filters.startTime);
    }

    if (filters.endTime) {
      filteredLogs = filteredLogs.filter(log => log.timestamp <= filters.endTime);
    }

    // æŒ‰æ“ä½œç±»å‹è¿‡æ»¤
    if (filters.action) {
      filteredLogs = filteredLogs.filter(log => log.action === filters.action);
    }

    // æŒ‰ç”¨æˆ·è¿‡æ»¤
    if (filters.userId) {
      filteredLogs = filteredLogs.filter(log => log.userId === filters.userId);
    }

    return {
      logs: filteredLogs,
      summary: this.generateAuditSummary(filteredLogs),
      filters: filters,
      generatedAt: Date.now()
    };
  }

  generateAuditSummary(logs) {
    const summary = {
      total: logs.length,
      byAction: {},
      byUser: {},
      byTime: {},
      suspiciousActivities: []
    };

    // æŒ‰æ“ä½œç±»å‹ç»Ÿè®¡
    logs.forEach(log => {
      summary.byAction[log.action] = (summary.byAction[log.action] || 0) + 1;
    });

    // æŒ‰ç”¨æˆ·ç»Ÿè®¡
    logs.forEach(log => {
      summary.byUser[log.userId] = (summary.byUser[log.userId] || 0) + 1;
    });

    // æŒ‰æ—¶é—´ç»Ÿè®¡
    const now = Date.now();
    const oneHourAgo = now - 60 * 60 * 1000;
    const oneDayAgo = now - 24 * 60 * 60 * 1000;

    summary.byTime = {
      lastHour: logs.filter(log => log.timestamp > oneHourAgo).length,
      lastDay: logs.filter(log => log.timestamp > oneDayAgo).length,
      older: logs.filter(log => log.timestamp <= oneDayAgo).length
    };

    // æ£€æµ‹å¯ç–‘æ´»åŠ¨
    summary.suspiciousActivities = this.detectSuspiciousActivities(logs);

    return summary;
  }

  detectSuspiciousActivities(logs) {
    const suspicious = [];
    
    // æ£€æµ‹é¢‘ç¹çš„æƒé™è¯·æ±‚
    const permissionRequests = logs.filter(log => log.action === 'REQUEST_PERMISSION');
    const recentPermissionRequests = permissionRequests.filter(
      log => Date.now() - log.timestamp < 5 * 60 * 1000
    );
    
    if (recentPermissionRequests.length > 5) {
      suspicious.push({
        type: 'EXCESSIVE_PERMISSION_REQUESTS',
        count: recentPermissionRequests.length,
        timeWindow: '5åˆ†é’Ÿ'
      });
    }

    // æ£€æµ‹å¤§é‡çš„æ•æ„Ÿæ•°æ®å­˜å‚¨
    const sensitiveDataOps = logs.filter(log => log.action === 'STORE_SENSITIVE_DATA');
    const largeDataOps = sensitiveDataOps.filter(log => log.dataSize > 10000);
    
    if (largeDataOps.length > 3) {
      suspicious.push({
        type: 'LARGE_SENSITIVE_DATA_STORAGE',
        count: largeDataOps.length,
        avgSize: largeDataOps.reduce((sum, op) => sum + op.dataSize, 0) / largeDataOps.length
      });
    }

    return suspicious;
  }

  // æ¸…ç†æ—§çš„å®¡è®¡æ—¥å¿—
  cleanupAuditLogs() {
    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
    this.auditLogs = this.auditLogs.filter(log => log.timestamp > thirtyDaysAgo);
    this.saveAuditLogs();
  }

  // å¯¼å‡ºå®¡è®¡æ—¥å¿—
  exportAuditLogs() {
    return {
      logs: this.auditLogs,
      exportTime: Date.now(),
      version: '1.0'
    };
  }

  // æ¸…é™¤å®¡è®¡æ—¥å¿—
  clearAuditLogs() {
    this.auditLogs = [];
    this.saveAuditLogs();
  }
}

export default SecurityAudit;
```

---

## æ€»ç»“

### é¡¹ç›®ä¼˜åŠ¿

1. **å®Œå…¨å‰ç«¯**ï¼šæ— éœ€åç«¯æœåŠ¡å™¨ï¼Œé™ä½å¼€å‘å’Œç»´æŠ¤æˆæœ¬
2. **éšç§ä¿æŠ¤**ï¼šæ‰€æœ‰å¤„ç†åœ¨ç”¨æˆ·è®¾å¤‡ä¸Šå®Œæˆï¼Œæ•°æ®ä¸ä¸Šä¼ ç¬¬ä¸‰æ–¹æœåŠ¡å™¨
3. **é«˜æ€§èƒ½**ï¼šä½¿ç”¨WebWorkerå’ŒWebAssemblyæå‡å¤„ç†æ€§èƒ½
4. **ç¦»çº¿å¯ç”¨**ï¼šæ”¯æŒç¦»çº¿ä½¿ç”¨ï¼Œç½‘ç»œä¾èµ–æ€§ä½
5. **è·¨å¹³å°**ï¼šåŒæ—¶æ”¯æŒå°ç¨‹åºå’ŒWebç‰ˆæœ¬

### æŠ€æœ¯ç‰¹è‰²

1. **çº¯å‰ç«¯å›¾åƒå¤„ç†**ï¼šåŸºäºCanvas APIå’Œè‡ªå®šä¹‰ç®—æ³•
2. **æ™ºèƒ½é“¾æ¥è§£æ**ï¼šæ”¯æŒå¤šå¹³å°é“¾æ¥çš„çº¯å‰ç«¯è§£æ
3. **æœ¬åœ°æ•°æ®å­˜å‚¨**ï¼šIndexedDB + LocalStorageçš„å®Œæ•´å­˜å‚¨æ–¹æ¡ˆ
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šWebWorker + åˆ†å—å¤„ç† + ç¼“å­˜æœºåˆ¶
5. **å®‰å…¨é˜²æŠ¤**ï¼šæ•°æ®åŠ å¯† + æƒé™ç®¡ç† + å®‰å…¨å®¡è®¡

### å¼€å‘å»ºè®®

1. **è¿­ä»£å¼€å‘**ï¼šå…ˆå®ç°åŸºç¡€åŠŸèƒ½ï¼Œå†é€æ­¥ä¼˜åŒ–
2. **æ€§èƒ½æµ‹è¯•**ï¼šé‡ç‚¹å…³æ³¨å¤§å›¾ç‰‡å¤„ç†çš„æ€§èƒ½è¡¨ç°
3. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›å®æ—¶åé¦ˆå’Œè¿›åº¦æ˜¾ç¤º
4. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œç”¨æˆ·å¼•å¯¼
5. **éšç§ä¿æŠ¤**ï¼šä¸¥æ ¼ä¿æŠ¤ç”¨æˆ·æ•°æ®å®‰å…¨

è¿™ä¸ªçº¯å‰ç«¯å»æ°´å°å°ç¨‹åºæ–¹æ¡ˆæä¾›äº†ä¸€ä¸ªå®Œæ•´çš„æŠ€æœ¯æ¶æ„ï¼Œå¯ä»¥åœ¨æ²¡æœ‰åç«¯æœåŠ¡å™¨çš„æƒ…å†µä¸‹å®ç°åŠŸèƒ½å®Œæ•´çš„å»æ°´å°å·¥å…·ã€‚